
<!-- -*- nxml -*- -->
<chapter>
  <title>Introduction</title>
  <section>
    <title>About This Document</title>
    <body>
      <p>
	This document describes the Instant NETCONF Manager (INM) Java
	library. It provides an overview of the architecture of the
	library, it's APIs including usages examples, and guidelines on
	how to extend the feature set.
      </p>
      <p>
	This guide is designed for developers who are planning to use
	the library. To use this document, you need a broad
	understanding of the Java programming language, XML, and the
	NETCONF protocol. Pointers to additional sources of information
	can be found in the <em>Recommended Reading</em> section.
      </p>
      <p>
	The examples in this guide requires access to a NETCONF server
	implementation. All examples have been tested with the Tail-f
	ConfD NETCONF implementation and while we believe it should work
	with all implementations compliant with RFC 4741 there may still
	be interoperability problems. Please report any issues to your
	technical contact. Tail-f can make an instance of the ConfD
	NETCONF implementation available remotely if needed, please
	contact your account manager.
      </p>
    </body>
  </section>
  <section>
    <title>Instant NETCONF Manager Overview</title>
    <body>
      <p>
        The <em>Instant NETCONF Manager</em> (INM) is a Java library
        that allows developers to rapidly integrate a fully featured
        <em>NETCONF</em> client into existing network management
        applications.
      </p>

      <p>
        The NETCONF protocol provides a programmatic interface
        enabling management applications to configure and monitor
        network elements. NETCONF uses <em>XML</em> for payload and
	for protocol messages. It provides standardized mechanisms to
	install, retrieve, manipulate, and delete the configuration
	and operational data on network elements.
      </p>
      
      <p>

        Development of a southbound NETCONF interface requires
        implementation of the basic NETCONF operations, session
        management, and use of a secure transport protocol. INM
        provides these features via a light weight class
        library. Developers work with configuration and operational data using a tree
        structured object model. This hides the complexity of the NETCONF
        protocol and its payload. Once an application or user initiates a task, for
        example changes the IP address on a specific interface, all
        aspects of the transaction are handled by the library. The
        figure below shows how the Instant NETCONF Manager fits into an
        existing element management application.
      </p>

      <img src="../pics/arch.png"
           width="12cm"
           caption="NETCONF client in an existing EMS/NMS"/>

      <p>
        INM is data model agnostic, i.e. it can be used to manage any
        NETCONF device without previous knowledge about the data being
        modeled by the device.
      </p>
    </body>
  </section>

  <section>
    <title>Recommended Reading</title>
    <body>
      <p>
        If the following resources are not familiar we recommend
        a closer look at them before you proceed:
      </p>
      
      <dl termtype="em">
        <dt>RFC 4741: NETCONF Configuration Protocol</dt>
        <dd><c>ftp://ftp.rfc-editor.org/in-notes/rfc4741.txt</c></dd>
        <dt>An XPATH tutorial</dt>
        <dd><c>http://www.w3schools.com/xpath/default.asp</c></dd>
      </dl>
      
      <p>
        Other topics introduced later in this document may be
        studied in-depth using the following resources:
      </p>

      <dl termtype="em">
	<dt>An XML tutorial</dt>
	<dd><c>http://www.w3schools.com/xml/default.asp</c></dd>
	<dt>An XML Schema tutorial</dt>
	<dd><c>http://www.w3schools.com/schema/default.asp</c></dd>
	<dt>RFC 4742: Using the NETCONF Configuration Protocol over
	Secure Shell (SSH)</dt>
	<dd><c>ftp://ftp.rfc-editor.org/in-notes/rfc4742.txt</c></dd>
      </dl>

    </body>
  </section>
  
  <section>
    <title>INM and the NETCONF Protocol</title>
    <body>
      <p>
        The NETCONF protocol is an IETF standard which defines a
        programmatic interface enabling applications to automate the
        configuration and monitoring of network elements.
      </p>

      <p>
        The NETCONF protocol can conceptually be partitioned into four
        layers, and the INM library is structured in a similar way. The
        <em>Transport interface</em> defines methods for the transport
        protocol. The <em>NetconfSession</em> contains the RPC-based
        mechanism and the standard NETCONF
        operations and <em>Element</em> represents the configuration
        and operational data as a tree of elements.
      </p>
      
      <code caption="NETCONF protocol layers"><![CDATA[
        Layer                      Example                          Java
       +-------------+   +-----------------------------+   +---------------------+
   (4) |   Content   |   |     Configuration data      |   |       Element      |
       +-------------+   +-----------------------------+   +---------------------+
              |                        |                              |
       +-------------+   +-----------------------------+   +---------------------+
   (3) | Operations  |   | <get-config>, <edit-config> |   |                     |
       +-------------+   +-----------------------------+   |                     | 
              |                        |                   |   NetconfSession    |
       +-------------+   +-----------------------------+   |                     |
   (2) |     RPC     |   |    <rpc>, <rpc-reply>       |   |                     |
       +-------------+   +-----------------------------+   +---------------------+ 
              |                        |                              |
       +-------------+   +-----------------------------+   +---------------------+
   (1) |  Transport  |   |   BEEP, SSH, SSL, console   |   | Transport interface |
       |   Protocol  |   |                             |   | SSHTransport        | 
       +-------------+   +-----------------------------+   +---------------------+ 
]]></code>            

      <p>
        The NETCONF protocol defines a set of operations which can be
        used to manipulate configurations:
      </p>

      <ul>
        <li><c>&lt;get-config&gt;</c></li>
        <li><c>&lt;edit-config&gt;</c></li>
        <li><c>&lt;delete-config&gt;</c></li>
        <li><c>&lt;lock&gt;</c></li>
        <li><c>&lt;unlock&gt;</c></li>
        <li><c>&lt;get&gt;</c></li>
        <li><c>&lt;close-session&gt;</c></li>
        <li><c>&lt;kill-session&gt;</c></li>
        <li><c>&lt;commit&gt;</c></li>
        <li><c>&lt;discard-changes&gt;</c></li>
        <li><c>&lt;copy-config&gt;</c></li>
        <li><c>&lt;validate&gt;</c></li>
      </ul>
      
      <p>
        The NETCONF protocol also defines a set of mandatory and
        optional capabilities:
      </p>

      <ul>
        <li><c>:writable-running</c></li>
        <li><c>:candidate</c></li>
        <li><c>:confirmed-commit</c></li>
        <li><c>:rollback-on-error</c></li>
        <li><c>:validate</c></li>
        <li><c>:startup</c></li>
        <li><c>:url</c></li>
        <li><c>:xpath</c></li>
      </ul>

      <p>
        All operations and capabilities are described in detail in RFC 4741.
      </p>

      <p>
        INM supports all of these operations and capabilities but also
        makes it possible to write custom capabilities and
        operations. This is described in the <em>NETCONF
        extensions</em> chapter in this document.
      </p>

      <p>
        The Tail-f ConfD NETCONF server provides additional custom
        capabilities also supported by INM:
	<dl termtype="c">
	  <dt>:transaction</dt>
	  <dd>A capability which introduces a number of custom
	  operations to provide transaction semantics</dd>
	  <dt>:with-defaults</dt>
	  <dd>A capability which introduces an alternative handling of
	  default values</dd>
	</dl>
	These custom
	capabilities and related operations are described in the
	ConfD User Guide.
      </p>
    </body>
  </section>

  <section>
    <title>Examples</title>
    <body>
      <p>
        The purpose of INM is to provide a Java API for managing
        configuration and operational data on NETCONF enabled devices. INM
        provides two main classes for this purpose:
      </p>

      <dl termtype="em">
        <dt>Element</dt>
        <dd>Represents configuration and operational data trees</dd>
        <dt>NetconfSession</dt>
        <dd>Performs appropriate NETCONF operations using
        <em>Element</em> trees</dd>
      </dl>

      <p>
        The Element and NetconfSession classes are described in
        detail later in this document and in the Javadoc
        documentation.
      </p>

      <p>
        To give you a quick start on how these classes can be used we
        provide three initial examples. These examples are
        available in the INM distribution and can be run as is. The
        examples assume that a NETCONF device is running on
        <c>netconf.example.com:2022</c> using SSH for transport.
      </p>

      <!--
      <p>
      Feel free
      to use this public NETCONF device for your own experimentation as
      long as you are aware of that this device is automatically 
      reinitialized each GMT 23:05.
      </p>
      -->

      <p>
	The examples below require that the
	NETCONF device on <c>netconf.example.com:2022</c> provides
	access to configuration data as defined by the following XML
	schema:
      </p>

      <code caption="simple.xsd"><![CDATA[
<xs:schema targetNamespace="http://example.com/ns/simple/1.0"
           xmlns="http://example.com/ns/simple/1.0"
           xmlns:simple="http://example.com/ns/simple/1.0"
           xmlns:xs="http://www.w3.org/2001/XMLSchema"
           elementFormDefault="qualified"
           attributeFormDefault="unqualified"
           xml:lang="en">
  <xs:element name="hosts">
    <xs:complexType>
      <xs:sequence>
        <xs:element name="host" minOccurs="0" maxOccurs="64">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="name" type="xs:string"/>
              <xs:element name="enabled" type="xs:boolean" 
                          minOccurs="0" confd:default="true"/>
              <xs:element name="numberOfServers" type="xs:unsignedInt"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
      </xs:sequence>
    </xs:complexType>
    <xs:key name="key_hosts_host">
      <xs:selector xpath="simple:host"/>
      <xs:field xpath="simple:name"/>
    </xs:key>
  </xs:element>
</xs:schema>
]]></code>

      <p>
	If you have access to Tail-f's ConfD NETCONF device you can
	use the following <em>confspec</em> file to run the examples:
      </p>

      <code caption="simple.cs"><![CDATA[
<?xml version="1.0"?>
<confspec xmlns="http://tail-f.com/ns/confspec/1.0"
          xmlns:xs="http://www.w3.org/2001/XMLSchema"
          targetNamespace="http://example.com/ns/simple/1.0">
  <elem name="hosts" >
    <elem name="host" minOccurs="0" maxOccurs="64">      
      <elem name="name" type="xs:string" key="true" />
      <elem name="enabled" type="xs:boolean" default="true"/>
      <elem name="numberOfServers" type="xs:unsignedInt"/>
    </elem>
  </elem>  
</confspec>
]]></code>
    </body>
    
    <subsection>
      <title>Example 1: Hello World</title>
      <body>
        <p>
          In the first example we just connect to the NETCONF device,
          ask for its configuration, convert it to XML and print it
          to the console.
        </p>

        <code caption="HelloWorld.java"><![CDATA[
import com.tailf.nml.*;

public class HelloWorld {
    static public void main(String args[]) {
        try {
            Transport transport =
                new SSHTransport("netconf.example.com", 2022);
            transport.authenticateWithPassword( "admin", "admin");    
            NetconfSession session = new NetconfSession(transport);
            NodeSet reply = session.getConfig();
            System.out.println(reply.toXMLString());
            session.closeSession();
        } catch (Exception e) {
            System.out.println(e);
        }
    }
}
]]></code>

        <p>
          If you run the above the following configuration is
          extracted from the device and printed on the console:
        </p>

        <pre><![CDATA[
$ java -classpath .:../NML.jar:../ganymed/ganymed-ssh2-build210.jar HelloWorld
<hosts xmlns="http://example.com/ns/simple/1.0">
   <host>
      <name>cecilia</name>
      <enabled>true</enabled>
      <numberOfServers>5</numberOfServers>
   </host>
   <host>
      <name>ellen</name>
      <enabled>true</enabled>
      <numberOfServers>4711</numberOfServers>
   </host>
   <host>
      <name>joe</name>
      <enabled>true</enabled>
      <numberOfServers>5</numberOfServers>
   </host>
   <host>
      <name>vera</name>
      <enabled>false</enabled>
      <numberOfServers>42</numberOfServers>
   </host>
</hosts>
]]></pre>

        <p>
          The extracted device configuration contains four hosts each
          with a unique name.
        </p>

        <p>
          Note how the configuration conforms to the XML schema
          introduced above.
        </p>

      </body>
    </subsection>

    <subsection>
      <title>Example 2: Something More Interesting</title>
      <body>
        <p>
          In this example we extract only a part of the device
          configuration using a subtree filter. We manipulate that
          part and send it back to the device.
        </p>
        
        <code caption="SomethingMore.java"><![CDATA[
import com.tailf.nml.*;

public class SomethingMore {
    static public void main(String args[]) {
        try {
            Transport transport =
                new SSHTransport("netconf.example.com", 2022);
            transport.authenticateWithPassword( "admin", "admin");    
            NetconfSession session = new NetconfSession(transport);
            // Create subtree filter 
            Element subtreeFilter =
                Element.create("http://example.com/ns/simple/1.0",
                                "/hosts/host[numberOfServers='5']");
            // Extract configuration from the RUNNING datastore
            NodeSet reply =
                session.getConfig(NetconfSession.RUNNING, subtreeFilter);
            if (reply.size() == 0) {
                System.out.println("/hosts/host[name='joe'] already deleted!");
                System.exit(255);
            }
            System.out.println("Current config:\n"+reply.toXMLString());
            Element hosts = reply.first();
            // Mark the host 'joe' for deletion
            hosts.markDelete("host[name='joe']");
            // Send the change back to the device
            session.editConfig(hosts);
            // Inspect the updated RUNNING configuration
            reply = session.getConfig();
            System.out.println("Resulting config:\n"+reply.toXMLString());
            session.closeSession();
        } catch (Exception e) {
            System.out.println(e);
        }
    }
}
]]></code>

        <p>
          A subtree filter is a tree structure as well, so we use a
          call to <em>Element.create</em> to instantiate a subtree
          filter specifying that <em>host</em> entries with
          <em>numberOfServers</em> equal to "5" should be chosen. We
          then call <em>NetconfSession.getConfig</em> with the subtree
          filter to extract the appropriate hosts. We then locally
          marks the host with <em>name</em> equals to "joe" for
          deletion with a call to
          <em>Element.markDelete</em>. Finally we send the change
          back to the device with a call to
          <em>NetconfSession.editConfig</em>.
        </p>

        <p>
          If you run the above the configuration is manipulated on the
          device and the following is printed on the console:
        </p>
          
        <pre><![CDATA[
$ java -classpath .:../NML.jar:../ganymed/ganymed-ssh2-build210.jar SomethingMore
Current config:
<hosts xmlns="http://example.com/ns/simple/1.0">
   <host>
      <name>cecilia</name>
      <enabled>true</enabled>
      <numberOfServers>5</numberOfServers>
   </host>
   <host>
      <name>joe</name>
      <enabled>true</enabled>
      <numberOfServers>5</numberOfServers>
   </host>
</hosts>

Resulting config:
<hosts xmlns="http://example.com/ns/simple/1.0">
   <host>
      <name>cecilia</name>
      <enabled>true</enabled>
      <numberOfServers>5</numberOfServers>
   </host>
   <host>
      <name>ellen</name>
      <enabled>true</enabled>
      <numberOfServers>4711</numberOfServers>
   </host>
   <host>
      <name>vera</name>
      <enabled>false</enabled>
      <numberOfServers>42</numberOfServers>
   </host>
</hosts>
]]></pre>       

        <p>
          In this example we used a subtree filter to extract a set of
          hosts. As an alternative an XPATH expression could have been
          used instead provided that the NETCONF server we talk to
	  supports the <c>:xpath</c> capability.
        </p>
      </body>
    </subsection>
    
    <subsection>
      <title>Example 3: Something Even More Interesting</title>
      <body>
	<p>
          In this example we revert the configuration back to its
	  original content. In example 2 we removed a host which we
	  here reinsert.
	</p>
        
        <code caption="SomethingEvenMore.java"><![CDATA[
import com.tailf.nml.*;

public class SomethingEvenMore {
    static public void main(String args[]) {
        try {
            Transport transport =
                new SSHTransport("netconf.example.com", 2022);
            transport.authenticateWithPassword( "admin", "admin");    
            NetconfSession session = new NetconfSession(transport);
            // Create subtree filter 
            Element hosts =
                Element.create("http://example.com/ns/simple/1.0", "/hosts");
            // Reinsert a new host 'joe' instance. If this host already
            // exists replace it. If it doesn't exist create it.
            Element joe =
                hosts.createPath("host[name='joe', numberOfServers='5']");
            joe.markReplace();
            System.out.println("Replacement config:\n"+ hosts.toXMLString());
            // Send the change back to the device
            session.editConfig(hosts);
            // Inspect the updated RUNNING configuration
            NodeSet reply = session.getConfig();
            System.out.println("Resulting config:\n"+reply.toXMLString());
            session.closeSession();
        } catch (Exception e) {
            System.out.println(e);
        }
    }
}
]]></code>

	<p>
	  This example is also available in the INM distribution. Try
	  it out and see what happens.
	</p>
      </body>
    </subsection>
  </section>

  <section>
    <title>Next Steps</title>
    <body>
      <p>
        The remaining chapters deal with the following topics:
      </p>
      
      <dl termtype="em">
        <dt>An overview of the INM classes</dt>
        <dd>Briefly goes through all classes provided by INM.</dd>
        <dt>Elements</dt>
        <dd>Describes the functionality provided by the Element
        class</dd>
        <dt>NETCONF sessions</dt>
        <dd>Describes the functionality provided by the NetconfSession
        class</dd> 
        <dt>NETCONF extensions</dt>
        <dd>Describes how to implement custom capabilities and
        operations.</dd>
      </dl>
      
      <p>
        The INM distribution also comes bundled with Javadoc documentation.
      </p>
    </body>
  </section>
</chapter>
<!-- -*- nxml -*- -->
<chapter>
  <title>An Overview of the INM Classes</title>
  <section>
    <title>Overview</title>
    <body>
      <p>
        The purpose of INM is to provide functionality to make it easy
        to manage configuration and operational elements on a NETCONF enabled
        device. The main classes (<em>Element</em> and
        <em>NetconfSession</em>) are described in separate chapters
	in this document.
      </p>
      
      <p>
        All INM classes are briefly introduced in the following
        sub-sections. For implementation details please refer to the
        Javadoc documentation.
      </p>
    </body>
  </section>

  <section>
    <title>The Element Class</title>
    <body>
      <p>
        The <em>Element</em> class is used to represent a simplified
        Document Object Model (DOM) tree of configuration
        elements. For example <em>NetconfSession.get</em> and
        <em>NetconfSession.getConfig</em> can be used to extract the
        configuration from a NETCONF device as an Element object.
      </p>
      
      <p>
        There are many methods in this class with the sole purpose to
        make it easy to create and manipulate element hierarchies.
      </p>
      
      <p>
        An Element class can also be used to represent a subtree
        filter which is a standard filtering mechanism in NETCONF. 
      </p>

      <p>
        An Element object always belongs to a namespace and has a
        name, a set of attributes, an optional value, and an optional set
        of Element children. Element also have a pointer to its
        parent Element object (to make it easy to traverse the
        tree). Element furthermore has a <em>PrefixMap</em> mapping
        namespace URIs to XML prefixes.
      </p>
    </body>
  </section>
  
  <section>
    <title>The NetconfSession Class</title>
    <body>
      <p>
        The <em>NetconfSession</em> class is the logical connection
        between a network administrator or network configuration
        application and a network device. A device must support at
        least one NETCONF session and should support multiple
        sessions.
      </p>
      
      <p>
        A NETCONF session towards a device is established by 
        the NetconfSession constructor which takes a
        <em>Transport</em> object as an argument. The Transport is
        responsible for the underlying transport mechanism.
      </p>
      
      <p>
        Additional Transport classes can easily be realised as
        custom implementations of the Transport interface.
      </p>
      
      <p>
        NETCONF operations are handled by the session using an RPC
        mechanism. It is possible to extend this class to make
        implementations of proprietary capabilities. The
        <em>ConfDSession</em> class is an example of such an
        extension.
      </p>
    </body>
  </section>
  
  <section>
    <title>The ConfDSession Class</title>
    <body>
      <p>
        The <em>ConfDSession</em> class extends the NetconfSession
        class and provides custom ConfD capabilities such as
        <em>:transactions</em> and <em>:with-defaults</em>. Read more
        about this topic in the ConfD User Guide.
      </p>
    </body>
  </section>
  
  <section>
    <title>The SSHTransport Class</title>
    <body>
      <p>
        The <em>SSHTransport</em> class implements the Transport
        interface and provides a SSH transport based on the Java2
        Ganymed SSH implementation.
      </p>
    </body>
  </section>
  
  <section>
    <title>The TCPTransport Class</title>
    <body>
      <p>
        The <em>TCPTransport</em> class implements the Transport
        interface and provides a clear-text TCP transport. This is a
        proprietary ConfD class and can only be used to connect to
        a ConfD NETCONF server.
      </p>
    </body>
  </section>

  <section>
    <title>The Attribute Class</title>
    <body>
      <p>
        The <em>Attribute</em> class represents an attribute attached to an Element. An attribute must have a name and a
        value.
      </p>
    </body>
  </section>

  <section>
    <title>The Prefix Class</title>
    <body>
      <p>
        The <em>Prefix</em> class is a sub-class of the
        <em>Attribute</em> class and results in an XML specific
        <em>xmlns</em> attribute when it reaches the NETCONF device
        such as <c>&lt;bar
        xmlns:foo="http://example.com/foo/1.0"&gt;</c>.
      </p>
    </body>
  </section>

  <section>
    <title>The PrefixMap Class</title>
    <body>
      <p>
        The <em>PrefixMap</em> represents a list of prefix
        mappings. Basically it is an <em>ArrayList</em> of
        Prefix objects. An Element has a <em>PrefixMap</em>
        which is used to find the namespace of any given prefix.
      </p>
    </body>
  </section>

  <section>
    <title>The NodeSet Class</title>
    <body>
      <p>
	Many of the methods in the library returns a set of Element
	objects. A <em>NodeSet</em> is an <em>ArrayList</em> of
	Element objects.
      </p>
    </body>
  </section>

  <section>
    <title>The Path Class</title>
    <body>
      <p>
        The <em>Path</em> class makes it possible to select elements
        from a configuration tree, i.e. an Element tree. A Path
        represents a small subset of the W3C XPATH 1.0
        recommendation. For example:
        <em>hosts/host[name="john"]</em> is a path expression 
        which selects all host elements with the name 'john'.
      </p>
    </body>
  </section>

  <section>
    <title>The PathCreate Class</title>
    <body>
      <p>
        The <em>PathCreate</em> class makes it possible to create
	a complete Element tree in a single operation. It is related to
        the Path class but the path is used for Element tree creation
        rather than selection.
      </p>
    </body>
  </section>
  
  <section>
    <title>The XMLParser Class</title>
    <body>
      <p>
        The <em>XMLParser</em> class is an XML parser that builds
	Element trees from string oriented XML.
      </p>
    </body>
  </section>

  <section>
    <title>The NMLException Class</title>
    <body>
      <p>
        Whenever an error occurs the INM library throws an instance
        of this class.
      </p>
    </body>
  </section>
</chapter>
<!-- -*- nxml -*- -->
<chapter>
  <title>Elements</title>
  <section>
    <title>Element class</title>
    <body>
      <p>
        The <em>Element</em> class is the base data structure for 
        configuration trees.
        It is also used for subtree filters, and all other possible situations
        where an XML structure is used in NETCONF.
        The Element class provide methods for creating, deleting and 
        modifying configuration trees.
      </p>
      
      <p>
        Several of the methods in the Element class takes a <em>path expression</em> 
	as an argument, where the path expression is used for 
        selecting a set of nodes within the element tree.
        The path expression shares the same syntax as the XPATH expressions.
        Please see the listed recommended reading for more information 
        about XPATH.
        Path expressions are implemented in the <em>Path</em> class.
      </p>
      <p>
        Note that the <em>Path</em> class does not contain a full 
        implementation of  the XPATH specification, just a small
        subset to make a selection of data within a subtree feasible.
      </p>
      <p>
	The following example of a Path expression will select all host nodes
	in a configuration tree which have an enabled field set to 'true':
	<code caption="Select all enabled hosts"><![CDATA[
      NodeSet full_config = session.getConfig();
      NodeSet all_enabled = full_config.get("hosts/host[enabled='true']");
      ]]></code>        
      </p>
      
      <p>
	To fully understand the Path expression the W3C recommendation for  XPath 
	(XML Path Language) should be studied, even though our implementation of a Path expression 
	is only a subset of the full XPath specification the basic principles are similar.
	(It is a subset since our focus lies in the configuration area rather than supporting 
	every feature a general XML document may have).
      </p>
      
      <p>	  
        In short: <em>path expressions</em> consists of several 
        <em>location steps</em> that will be taken
        in the element subtree. The location steps are separated with '/':
        <p>
          <c>locationStep1/locationStep2/... /locationStepN</c>
        </p>
        A location step is <em>"to step down in the subtree"</em>.
        A location step has three parts:
        <ol>
          <li>An axis, which specifies the tree relationship between the 
            nodes selected by the location step and the context node. 
            This can be omitted. Only "self" and "child" are 
            valid axis specifiers in the path expression. "child" is default if committed.
          </li>
          <li>A node test, which specifies the node type and expanded-name 
            of the nodes selected  by the location step. A node test is a 
            prefixed name or just the name.
          </li>
          <li>Zero or more predicates, which use arbitrary expressions to 
            further refine the set of nodes selected by the location step.
          </li>
        </ol>
      </p>
      
      <p>
        The syntax for a location step is the axis name and node test 
        separated by a double colon, followed by zero or more expressions 
        each in square brackets. 
        For example, in <em>child::para[position()=1]</em>, 
        <em>child</em> is the name of the axis, 
        <em>para</em> is the node test and <em>[position()=1]</em> is a 
        predicate.
      </p>
     
      <p>
        The result of evaluating each location step is a node set which 
        will be given to the next
        step until all steps are evaluated or the node set is empty.
        The resulting node set is returned.
          Examples of using path expressions will follow below.
      </p>
      
      <p>
        With the <em>create</em> methods in the <em>Element</em> class it is 
        possible to create new element trees. The <em>create()</em> methods 
        take a <em>create path expression</em>
        as an argument, and it is similar to the <em>path expression</em> 
        except that the expression
        will try to create the location steps that do not already exist. 	  
      </p>

      <p>
	The following create path expression will create a host named "john":	  
	<code caption="Create host 'john'"><![CDATA[
      Element john_tree = subtree.createPath("hosts/host[name='john', enabled='true']");
      ]]></code>        
      </p>
      
      <p>
        The algorithm is:
        <ol>
          <li> Step down the locations steps as long as we get a non empty 
            node set as a result. (This means that we step down the already existing nodes
	    in the tree, until we can't step down any further.)
          </li>
          <li> Create the rest of the location steps.
          </li>
        </ol>
        The <em>create path expression</em> is implemented in the 
          <c>PathCreate</c> class.          
      </p>
      

    </body>
  </section>

  <section>
    <title>Selection using a path expression</title>
    <body>        
      <p>
        To select data from a local configuration tree, a path expression is 
        used. The <c>Path</c> class contains the implementation
        of the path expressions, but path expressions are intended to be used 
        directly from the 
        <c>Element.get(String pathString)</c> and
        <c>NodeSet.get(String pathString)</c> methods.
      </p>
      <code caption="Select host 'john' from the configuration tree"><![CDATA[
      NodeSet full_config = session.getConfig();
      NodeSet all_johns = full_config.get("hosts/host[name='john']");
      Element john = all_johns.first();
      ]]></code>        

      <p>
        From the full configuration received a selection is made locally
        with <c>get("hosts/host[name='john']")</c>.
        The path expression is evaluated on the context node from top to bottom.
	The context node is the node we invoke the 'get' method on, e.g the selecion
	is made from this node.
      </p>
      
      <p>
        The expression consists of a number of steps separated with '/', so
        the expression contains two steps: <c>hosts</c> and 
        <c>host[name='john']</c>.
        The last step also contains a predicate (a test which evaluates to 
        either 'true' or 'false').
        The result of evaluating each step is a <em>NodeSet</em> of elements, 
        that is given as a context to the next step. When all steps are 
        evaluated the resulting <em>NodeSet</em> is returned.
        <ol>
          <li>
            Select all <c>hosts</c> children of the context node.
          </li>
          <li>
            Select all <c>host</c> children of the nodes from the previous 
            step. Only include the nodes where the predicate expression 
            <c>name='john'</c> evaluates to 'true'.
          </li>
        </ol>
        So the meaning of the expression is: 
        <em>"select all host elements with a child named 'name' whose 
        value is 'john'"</em>.
      </p>
    </body>
  </section>
  
  
  <section>
    <title>Creating an element subtree</title>
    <body>        
      <p>
        To create a new element subtree there are class methods for 
        create in <c>Element.create(Prefix prefix,String pathStr)</c>.
        This is convenient for creating for example <em>subtree filters</em>.
        A prefix map needs to be given to resolve prefixes in the path. A 
        namespace can also be given if no prefixes are used in the path.
      </p>
      <code caption="Select 'hosts' from the configuration tree"><![CDATA[
      Element subtreeFilter = Element.create("http://tail-f.com/ns/simple/1.0","/hosts");
      NodeSet hosts = sess.get(subtreeFilter);
      ]]></code>        
    </body>
  </section>


  <section>
    <title>Attributes</title>
    <body>        
      <p>
        Configuration elements can have attributes.
        For each element there is a set of attributes attached to it.
        To set an attribute the <c>Element.setAttr(String name,String value)</c>
        should be used. And to get the attribute(s) <c>getAttrs()</c> and 
        <c>getAttr(String attrName)</c> can be used. <br/>
        Attributes can also be given in <em>create path expressions</em> as 
        shown in the following example.
        In the following example the attribute "myattr" 
        (attributes are prefixed with '@') is created on the host element.
      </p>
      <code caption="Create host with attribute"><![CDATA[
      Element tree = Element.create("http://tail-f.com/ns/simple/1.0",
                                      "/hosts/host[name='john', @myattr='enabled']");
      ]]></code>        
    </body>
  </section>
  
  <section>
    <title>Modifying configuration element subtrees with NETCONF</title>
    <body>        
      <p>
        To modify elements on the device the <em>editConfig</em> operation is 
        used and a configuration tree is provided as an argument.
        The configuration is sent to the device, which will be updated with 
        the new configuration. For each configuration element it is possible 
        to set an operation attribute which is used for controlling what needs 
        to be done. The value is one of: <em>create</em>, <em>delete</em>, 
        <em>replace</em> or <em>merge</em>.
        The meaning is the following:
        <dl termtype="em">
          <dt>delete</dt>
	  <dd>The element and its subtree will be deleted</dd>
          <dt>create</dt>
          <dd>A new instance will be created</dd>
          <dt>merge</dt>
          <dd>Merges this configuration with the existing one</dd>
          <dt>replace</dt>
          <dd>Replaces the configuration with this one</dd>
        </dl>
        The operation attribute can be set with the following methods:
        <c>markDelete()</c>, <c>markReplace()</c>, <c>markMerge()</c>, 
        <c>markCreate()</c>.
        For example the <c>markCreate()</c> is the equivalent of setting
        the operation attribute to 'create':
        <c>setAttr(Element.NETCONF_NAMESPACE,"operation","create")</c>
        
      </p>
      <p>
        The following is an example of how to delete a 'host' node 
        whose name (sub-element) is 'john'.
      </p>
      <code caption="Delete host 'john'"><![CDATA[
      Element hosts = Element.create("http://tail-f.com/ns/simple/1.0",
                                       "/hosts/host[name='john']");
      hosts.markDelete("host[name='john']");
      sess.editConfig(hosts);
      ]]></code>                  

      <p>
        Consider the following code which will create a subtree filter 
        that creates a <em>host</em> and deletes a <em>host</em> in a device:
      </p>          

      <code caption="Core for creating a host and deleteing another host"><![CDATA[
      Element hosts = Element.create("http://tail-f.com/ns/simple/1.0","/hosts");
      Element ola = hosts.createPath("host[name='ola', address='10.0.0.4']");
      Element john= hosts.createPath("host[name='john', address='10.0.0.5']");
      ola.markDelete();
      john.markCreate();
      System.out.println( hosts.toXMLString() );
      session.editConfig(hosts);
      ]]></code>                  
      <p>
        This will result in the following element tree:
      </p>
      <img src="../pics/hosts-tree.png"
           width="16.5cm"
           caption="A tree of Element objects"/>


      <p>
        The printed tree will look like this:
      </p>
      <code caption="The printed XML tree"><![CDATA[
<hosts xmlns="http://tail-f.com/ns/simple/1.0">
    <host xc:operation="delete">
      <name>ola</name>
      <address>10.0.0.4</address>
    </host>
      <host xc:operation="create">
      <name>john</name>
      <address>10.0.0.5</address>
    </host>
</hosts>
      ]]></code>
      <p>
        Notice that the prefix 'xc' on the operations attributes are 
        a default prefix mapping of 'xc' to the NETCONF namespace
        "urn:ietf:params:xml:ns:netconf:base:1.0" where the 
        <em>operations</em> attribute is stored.
        The default prefix mappings can be changed. 
        They are fully accessible from <c>Element.defaultPrefixes</c>.
      </p>
    </body>
  </section>

  <section>
    <title>Writing configuration</title>
    <body>        
      <p>
        Configuration element trees can be converted to an XML string
        representation with the <c>toXMLString()</c> method.
        This can be used for saving the configuration to a file for example.
      </p>
      <code caption="Save configuration to file"><![CDATA[
      // get config from device
      NodeSet config = sess.getConfig();
      // Open an output stream
      fout = new FileOutputStream ("myconfig.xml");
      // Print the config
      new PrintStream(fout).println( config.toXMLString() );
      fout.close();             
      ]]></code>                  
    </body>
  </section>
  
  <section>
    <title>Reading configuration</title>
    <body>        
      <p>
        Configuration returned from the NETCONF session is
        parsed with the <em>XMLParser</em> class.
        This will build up a configuration tree. The 
        same parser can be used for reading a configuration file.
      </p>
      <code caption="Read configuration from file"><![CDATA[
      String filename = "myconfig.xml";
      Element tree = new XMLParser().readFile(filename);
      System.out.println( tree.toXMLString() );
      ]]></code>                  
    </body>
  </section>

  <section>
    <title>Prefixes</title>
    <body>        
      <p>
        Prefixes are used in path expressions to express that elements
        belong to a certain namespace. A prefix-mapping must be given 
        in order to resolve the namespace from a prefix.
        For example:
      </p>
      <code caption="Create element tree which belongs to different namespace"><![CDATA[
      Element t = Element.create( new Prefix("aaa","http://aaa/ns"),
                                    "/aaa:hosts/aaa:host");
      ]]></code>                  
      <p> 
        The elements prefixed with 'aaa' will belong to the namespace "http://aaa/ns".
      </p>
      <p> There is also a default prefix map which is a convenient
      place to have common prefix mappings stored.
      It is a static <em>PrefixMap</em> in the <em>Element</em> class.
      For example the 'operation' attributes belong to the 
      namespace "urn:ietf:params:xml:ns:netconf:base:1.0". 
      To not have to set a prefix map on every <em>Element</em> element
      where the attribute 'operation' is used, it is simply put in a top level
      default prefix map, which is put in the RPC header of every 
      NETCONF message.
      </p>
      <code caption="Add a default prefix mapping of 'aaa' to our commonly used namespace"><![CDATA[
      Element.defaultPrefixes.set( new Prefix("aaa", "http://aaa/ns/whatever"));
      ]]></code>                
      <p>
        Note that prefixes as well as namespaces need to be unique.
        Two prefixes mapping to the same namespace are not allowed.
      </p>
    </body>
  </section>

</chapter>

<!-- -*- nxml -*- -->
<chapter>
  <title>NETCONF sessions</title>
    <section>
      <title>The NetconfSession class</title>
      <body>
        <p>
          The <c>NetconfSession</c> class implements the standard
          NETCONF operations.  This class can be extended to implement
          proprietary capabilities and operations The following
          operations are supported:
          <dl termtype="em">
            <dt>get </dt>
            <dd>
              Retrieve running configuration and device state information.
            </dd>
            <dt>getConfig</dt>
            <dd>
              Get the device configuration data.
            </dd>
            <dt>editConfig</dt>
            <dd>
              Edit the configuration on the device.
            </dd>
            <dt>copyConfig </dt>
            <dd>
              Creates or replaces an entire configuration datastore with the
              contents of another complete configuration datastore.  If the
              target datastore exists, it is overwritten.  Otherwise a new one
              is created if allowed.
            </dd>
            <dt>deleteConfig</dt>
            <dd>
              Deletes a configuration datastore.
            </dd>
            <dt>lock</dt>
            <dd>
              The lock operation allows the client to lock the configuration
              system of a device.  Such locks are intended to be short-lived and
              allow a client to make a change without fear of interaction with
              other NETCONF clients, non-NETCONF clients (e.g., SNMP and command
              line interface (CLI) scripts), and human users.       
            </dd>
            <dt>unlock</dt>
            <dd>
              The unlock operation is used to release a configuration lock,
              previously obtained with the <c>lock</c> operation.
            </dd>
            <dt>validate </dt>
            <dd>
              This protocol operation validates the contents of the specified configuration.
            </dd>          
            <dt>commit </dt>
            <dd>
              When a candidate configuration's content is complete, the
              configuration data can be committed, publishing the data set to
              the rest of the device and requesting the device to conform to
              the behavior described in the new configuration.
            </dd>           
            <dt>discardChanges</dt>
            <dd>
              If the client decides that the candidate configuration should not be
              committed, the <c>discardChanges</c> operation can be used to revert the
              candidate configuration to the current running configuration.
            </dd>
            <dt>closeSession</dt>
            <dd>
              Request graceful termination of a NETCONF session.
            </dd>
            <dt>killSession</dt>
            <dd>
              Force the termination of a NETCONF session.
            </dd>
          </dl>
        </p>
      </body>
    </section>
      
    <section>
        <title>Get configuration</title>
        <body>    
          <p>
            The session will return a configuration tree from many of its 
            operation methods.
            In the example below a subtree filter is built to filter
            the hosts from the configuration.
            The returned "hosts" is really a set of configuration trees, since many 
	    subtrees can match the filter.
	    A NodeSet contains zero or more Elements (subtrees).
          </p>
          <code caption="Get configuration tree using subtree filter"><![CDATA[
Transport tr = new SSHTransport("127.0.0.1", 2022);
tr.authenticateWithPassword("admin", "admin");
NetconfSession sess= new NetconfSession( tr );
ConfElem subtreeFilter = ConfElem.create("http://tail-f.com/ns/simple/1.0","/hosts");
NodeSet reply = sess.get(subtreeFilter);
Element hosts = reply.first();
System.out.println("config tree: "+ hosts.toXMLString() );
]]></code>      


          <p>
            Another way would be to use an XPATH expression instead
            of a subtree filter. 
            This example will return the same result as the example above.
            Not all NETCONF server implementations support the XPATH capability.
          </p>
          <code caption="Get configuration using XPATH filtering"><![CDATA[
Transport tr = new SSHTransport("127.0.0.1", 2022);
tr.authenticateWithPassword("admin", "admin");
NetconfSession sess= new NetconfSession( tr );
NodeSet hosts = sess.get("/hosts");
System.out.println("config tree: "+ hosts.toXMLString() );
]]></code>      
        </body>    
      </section>
      
    <section>
      <title>Transactions using candidates example</title>
      <body>      
        <p>
          Let's assume that we need to update several devices 
          in a transaction based manner. 
          Either all devices are updated or none of them.
          This can be achieved with the <c>confirmedCommit</c> operation,
          which a commit operation with a specified timeout period.
        </p>
        <p>
          The <c>:confirmed-commit</c> capability indicates that the server
          supports the confirmed commit.
        </p>
        <p>
          A confirmed commit operation must be reverted if a follow-up commit
          (called the "confirming commit") is not issued within 600 seconds (10
          minutes).  The timeout period can be adjusted with the
          timeout parameter. 
        </p>
        <code caption="Transaction using candidates"><![CDATA[
try {
    // Start (NETCONF) sessions towards devices
    Transport ssh1 = new Transport("127.0.0.1","ola","secret");
    Transport ssh2 = new Transport("10.0.0.23","ola","secret");
    NetconfSession dev1 = new NetconfSession(ssh1);
    NetconfSession dev2 = new NetconfSession(ssh2);
 
    // take locks on CANDIDATE datastore so that we are not interrupted
    dev1.lock( NetconfSession.CANDIDATE );
    dev2.lock( NetconfSession.CANDIDATE );
 
    // reset candidates so that CANDIDATE is an exact copy of running
    dev1.copyConfig(NetconfSession.RUNNING, NetconfSession.CANDIDATE);
    dev2.copyConfig(NetconfSession.RUNNING, NetconfSession.CANDIDATE);
 
    // Get system configuration from dev1
    ConfElem sys1 = dev1.getConfig("/system").first();
 
    // Manipulate element trees locally
    sys1.setValue("dns","83.100.1.1");
    sys1.setValue("gateway","10.0.0.1");
 
    // Write back the updated element tree to both devices
    dev1.editConfig( NetconfSession.CANDIDATE, sys1 );
    dev2.editConfig( NetconfSession.CANDIDATE, sys1 );
  
    // candidates are now updated
    dev1.confirmedCommit(60);
    dev2.confirmedCommit(60);
  
    // now commit them
    dev1.commit();
    dev2.commit();
 
    dev1.unlock( NetconfSession.CANDIDATE );
    dev2.unlock( NetconfSession.CANDIDATE );
  
   } catch (Exception e) {
     // Devices will rollback within 1 minute unless the editConfig failed
   }
]]></code>      
      </body>
    </section>  
  </chapter>

<!-- -*- nxml -*- -->
<chapter>
  <title>NETCONF extensions</title>
  <section>
    <title>Proprietary NETCONF capabilities</title>
    <body>
      <p>
        NETCONF allows a client to discover the set of protocol extensions
        supported by a server.  These <em>capabilities</em> permit the client to
          adjust its behavior to take advantage of the features exposed by the
          device. Each peer advertises its capabilities by sending them
          during an initial capabilities exchange.  Each peer needs to
          understand only those capabilities that it might use and must ignore
          any capability received from the other peer that it does not require
          or does not understand.         
      </p>
    </body>
  </section>
  
  <section>
    <title>ConfD capabilities</title>
    <body>
      <p>
        The ConfD implementation of NETCONF have the following additional capabilities:
      </p>
      
      <dl termtype="c">
        <dt>:with-defaults</dt>
        <dd>The <c>:with-defaults</c> capability introduces an 
        attribute 'with-defaults' which can be used in the 'rpc'
        element when the operation is 'get', 'get-config', or
        'copy-config', to control if default values are to be
        returned by the NETCONF server or not.  If 'with-defaults'
        is 'true', default values are included.  If
        'with-defaults' is "false", default values are not included.  
        </dd>
        <dt>:action</dt>
        <dd>The 'action' capability introduces a new rpc method which 
        is used to invoke actions (methods) defined in the data model. 
        When an action is invoked, the instance on which the
        action is invoked is explicitly identified by an hierarchy
        of configuration or state data.
        </dd>
        <dt>:transactions</dt>
        <dd>The 'transactions' capability introduces four new rpc
        methods which are used to control a two-phase commit
        transaction on the NETCONF server.  The normal
        'editConfig' operation is used to write data in the
        transaction, but the modifications are not applied until
        an explicit 'commitTransaction' is sent.
        </dd>
      </dl>
      
      <p>
        A typical sequence of operations looks like this:
        <code caption="Transaction using candidates"><![CDATA[
  C                           S
  |                           |
  |  capability exchange      |
  |-------------------------->|
  |<------------------------->|
  |                           |
  |   <start-transaction>     |
  |-------------------------->|
  |<--------------------------|
  |         <ok/>             |
  |                           |
  |     <edit-config>         |
  |-------------------------->|
  |<--------------------------|
  |         <ok/>             |
  |                           |
  |  <prepare-transaction>    |
  |-------------------------->|
  |<--------------------------|
  |         <ok/>             |
  |                           |
  |   <commit-transaction>    |
  |-------------------------->|
  |<--------------------------|
  |         <ok/>             |
  |                           |
]]></code>      
      </p>
    </body>
  </section>
  
  <section>
    <title>Implementing proprietary capabilities</title>
    <body>
      <p>
        <c>ConfDSession.class</c> implements the ConfD specific capabilities.
        It extends the <c>NetconfSession</c> class, and all NetconfSessions methods are 
        inherited and can be used from ConfDSession.
        
        <code caption="ConfDSession with a TCPTransport (works only with ConfD)"><![CDATA[
Transport tr = new TCPTransport("127.0.0.1", 2023, "admin", "501",
                                "501", "", "/Users/ola", "");
ConfDSession sess= new ConfDSession( tr );       
sess.setWithDefaults(true);
NodeSet config = sess.get("hosts");
]]></code>      
      </p>
      <p>
        At the constructor, the ConfDSession needs to set the Transport object,
        register its capabilities towards the  NetconfSession class and send out
        the initial hello message. 
      </p>
      <code caption="Constructor for the ConfDSession class"><![CDATA[
/**
 * Constructor. Creates a new session object 
 * using the given transport object.
 *
 * @see SSHTransport
 * @see TCPTransport
 *
 * @param transport Transport object 
 */
public ConfDSession( Transport transport ) 
    throws NMLException, IOException  {
   super();
   setTransport(transport);
   setCapability(WITH_DEFAULTS_CAPABILITY);
   setCapability(ACTIONS_CAPABILITY);
   setCapability(TRANSACTIONS_CAPABILITY);
   hello();
   // parse capabilities returned from server.
   ...
]]></code>      
      <p>
        To implement a specific proprietary operation, there are a few
        helpful <em>protected</em> methods that can be used.
        Encoding the RPC header is such a method, that typically we don't want
        to do ourselves.
      </p>
      <code caption="Example implementation of the 'action' operation"><![CDATA[
/**
 * Action capability.
 * An action that does not return any result value, replies
 * with the standard 'ok' element. If a result value is returned,
 * it is encapsulated within a returned 'data' element.
 *
 * @param data element tree with action-data
 */
public Element action(Element data) throws NMLException, IOException {
   Transport out= getTransport();
   encode_rpc_begin(out);
   out.println("<action xmlns=\"http://tail-f.com/ns/netconf/actions/1.0\">");
   out.print("<data>");
   data.encode( out );
   out.println("</data>");
   out.println("</action>");
   encode_rpc_end(out); 
   out.flush();
   // parse reply and return
   return recv_rpc_reply();
}
]]></code>                  
      <p>
        The reply returned from an action can be either 'ok' or 
        'data'. The reply element tree is returned.
      </p>
      <code caption="Read reply from server. Either 'ok' or 'data'"><![CDATA[
Element recv_rpc_reply() throws NMLException, IOException {
   Transport in= getTransport();
   StringBuffer reply = in.readOne();
   Element t= parser.parse( reply.toString() );
   Element ok= t.getFirst("self::rpc-reply/ok");
   if (ok!=null) return ok;
   Element data= t.getFirst("self::rpc-reply/data");
   if (data!=null) return data;
   /* rpc-error */
   throw new NMLException(NMLException.RPC_REPLY_ERROR,t);
}
]]></code>                  
    </body>
  </section>
</chapter>

<!-- -*- nxml -*- -->
<chapter>
  <title>Notifications</title>
  <section>
    <title>Notifications</title>
    <body>
      <p>
        NETCONF notifications are defined in the IETF draft: 
      </p>
      <p>
	<em>
	  "NETCONF Event Notifications" -
          "draft-ietf-netconf-notification-11.txt" </em>
      </p>
      <p>
	A NETCONF client indicates interest in receiving event 
	notifications from a NETCONF server by creating a subscription
	to receive event notifications. The NETCONF server replies to 
	indicate whether the subscription request was successful and, 
	if it was successful, begins sending the event notifications 
	to the NETCONF client as the events occur within the system.  
	These event notifications will continue to be sent until
	either the NETCONF session is terminated or the subscription
	terminates for some other reason.  The event notification
	subscription allows a number of options to enable the NETCONF client
	to specify which events are of interest.  These are specified when
	the subscription is created.
      </p>

      <p>
        The NetconfSession class provides a few methods for the notifications:
	<dl termtype="em">
	  <dt>createSubscription()</dt>
	  <dd> 
	    creates a subscription to the standard NETCONF stream.
	  </dd>
	  <dt>createSubscription(String streamName)</dt>
	  <dd>
	    creates a subscription to the given streamName.
	  </dd>
	  <dt>createSubscription(String streamName, NodeSet|String eventFilter,String startTime, String stopTime)</dt>
	  <dd>creates a subscription to the given streamName, an eventFilter is provided to filter 
	    events on the server side, and a startTime and stopTime is used for replaying old events 
	    from the event log.
	    <dl termtype="em">
	      <dt>eventFilter</dt>
	      <dd>
		indicates which subset of
		all possible events is of interest.  This is either a subtree
		filter, or an XPath string expression 
		(then the server needs to suport the :xpath capability).
		If not present, all events not
		precluded by other parameters will be sent.
	      </dd>
	      <dt>startTime</dt>
	      <dd>
		triggers the replay feature
		and indicate that the replay should start at the time
		specified.  If startTime is not present, 
		this is not a replay subscription.  
		It is not valid to specify start times that are
		later than the current time.  If the startTime specified is
		earlier than the log can support, the replay will begin with
		the earliest available notification.
		This parameter is of type dateTime.		  
	      </dd>
	      <dt>stopTime</dt>
	      <dd>
		is used with the optional replay feature to 
		indicate the newest notifications of
		interest.  If stop time is not present, the notifications will
		continue until the subscription is terminated.  Must be used
		with and be later than startTime.  Values of stopTime in
		the future are valid.  This parameter is of type dateTime.
	      </dd>	      
	    </dl>
	  </dd>
	  <dt>getStreams()</dt> 
	  <dd> 
	    returns the available streams.
	  </dd>
	  <dt>receiveNotification()</dt>
	  <dd>
	    performs a blocking read. 
	    This method will return the received notification.
	  </dd>
	</dl>
      </p>
      
      <p>
        Here's an example of how the NETCONF notifications class can be used.
	A subscription is made and the thread will do a blocking read 
	with the <c>receiveNotification()</c> method.
      </p>
      
      <code caption="How to receive NETCONF notifications"><![CDATA[
     Transport tr = new SSHTransport("127.0.0.1", 2022);
     tr.authenticateWithPassword( "admin", "admin");
     NetconfSession sess= new NetconfSession( tr );
     // Query streams
     NodeSet reply = sess.getStreams();	    
     System.out.println("got streams:"+ reply.toXMLString());	

     // create subscription. subscribe to "interface" stream
     sess.createSubscription("interface");

     // receive notifications
     while (true) {
	    notif= sess.receiveNotification();
	    System.out.println("Got: "+notif.toXMLString());
     }
     ]]></code>        
      
    </body>
  </section>
  
  
  <section>
    <title>Replay feature</title>
    <body>        
      <p>
	Replay is the ability to create an event subscription that will
	resend recently generated notifications, or in some cases send them
	for the first time to a particular NETCONF client.  These
	notifications are sent the same way as normal notifications.
      </p>

      <p>
	A replay of notifications is specified by including the optional
	startTime parameter to the subscription command, which indicates
	the start time of the replay.  The end time is specified using the
	optional stopTime parameter.  If not present, notifications will
	continue to be sent until the subscription is terminated.
      </p>
      
      <p>
	A notification stream that supports replay is not expected to have an
	unlimited supply of saved notifications available to accommodate any
	replay request.
      </p>
      
      <p>
	The actual number of stored notifications available for retrieval at
	any given time is a NETCONF server implementation specific matter.
	Control parameters for this aspect of the feature are outside the
	scope of this document.
      </p>
      
    </body>
  </section>


  <section>
    <title>Interleave capability</title>
    <body>        
      <p>
	Theres an Interleave capability that 
	indicates that the NETCONF peer supports the ability to interleave 
	other NETCONF operations within a Notification subscription.
	This means the NETCONF server must receive, process and respond 
	to NETCONF requests on a session with an active notification subscription.	
      </p>

    </body>
  </section>
  
</chapter>

