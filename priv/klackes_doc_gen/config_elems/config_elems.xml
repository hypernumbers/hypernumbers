<!-- -*- nxml -*- -->
<chapter>
  <title>Elements</title>
  <section>
    <title>Element class</title>
    <body>
      <p>
        The <em>Element</em> class is the base data structure for 
        configuration trees.
        It is also used for subtree filters, and all other possible situations
        where an XML structure is used in NETCONF.
        The Element class provide methods for creating, deleting and 
        modifying configuration trees.
      </p>
      
      <p>
        Several of the methods in the Element class takes a <em>path expression</em> 
	as an argument, where the path expression is used for 
        selecting a set of nodes within the element tree.
        The path expression shares the same syntax as the XPATH expressions.
        Please see the listed recommended reading for more information 
        about XPATH.
        Path expressions are implemented in the <em>Path</em> class.
      </p>
      <p>
        Note that the <em>Path</em> class does not contain a full 
        implementation of  the XPATH specification, just a small
        subset to make a selection of data within a subtree feasible.
      </p>
      <p>
	The following example of a Path expression will select all host nodes
	in a configuration tree which have an enabled field set to 'true':
	<code caption="Select all enabled hosts"><![CDATA[
      NodeSet full_config = session.getConfig();
      NodeSet all_enabled = full_config.get("hosts/host[enabled='true']");
      ]]></code>        
      </p>
      
      <p>
	To fully understand the Path expression the W3C recommendation for  XPath 
	(XML Path Language) should be studied, even though our implementation of a Path expression 
	is only a subset of the full XPath specification the basic principles are similar.
	(It is a subset since our focus lies in the configuration area rather than supporting 
	every feature a general XML document may have).
      </p>
      
      <p>	  
        In short: <em>path expressions</em> consists of several 
        <em>location steps</em> that will be taken
        in the element subtree. The location steps are separated with '/':
        <p>
          <c>locationStep1/locationStep2/... /locationStepN</c>
        </p>
        A location step is <em>"to step down in the subtree"</em>.
        A location step has three parts:
        <ol>
          <li>An axis, which specifies the tree relationship between the 
            nodes selected by the location step and the context node. 
            This can be omitted. Only "self" and "child" are 
            valid axis specifiers in the path expression. "child" is default if committed.
          </li>
          <li>A node test, which specifies the node type and expanded-name 
            of the nodes selected  by the location step. A node test is a 
            prefixed name or just the name.
          </li>
          <li>Zero or more predicates, which use arbitrary expressions to 
            further refine the set of nodes selected by the location step.
          </li>
        </ol>
      </p>
      
      <p>
        The syntax for a location step is the axis name and node test 
        separated by a double colon, followed by zero or more expressions 
        each in square brackets. 
        For example, in <em>child::para[position()=1]</em>, 
        <em>child</em> is the name of the axis, 
        <em>para</em> is the node test and <em>[position()=1]</em> is a 
        predicate.
      </p>
     
      <p>
        The result of evaluating each location step is a node set which 
        will be given to the next
        step until all steps are evaluated or the node set is empty.
        The resulting node set is returned.
          Examples of using path expressions will follow below.
      </p>
      
      <p>
        With the <em>create</em> methods in the <em>Element</em> class it is 
        possible to create new element trees. The <em>create()</em> methods 
        take a <em>create path expression</em>
        as an argument, and it is similar to the <em>path expression</em> 
        except that the expression
        will try to create the location steps that do not already exist. 	  
      </p>

      <p>
	The following create path expression will create a host named "john":	  
	<code caption="Create host 'john'"><![CDATA[
      Element john_tree = subtree.createPath("hosts/host[name='john', enabled='true']");
      ]]></code>        
      </p>
      
      <p>
        The algorithm is:
        <ol>
          <li> Step down the locations steps as long as we get a non empty 
            node set as a result. (This means that we step down the already existing nodes
	    in the tree, until we can't step down any further.)
          </li>
          <li> Create the rest of the location steps.
          </li>
        </ol>
        The <em>create path expression</em> is implemented in the 
          <c>PathCreate</c> class.          
      </p>
      

    </body>
  </section>

  <section>
    <title>Selection using a path expression</title>
    <body>        
      <p>
        To select data from a local configuration tree, a path expression is 
        used. The <c>Path</c> class contains the implementation
        of the path expressions, but path expressions are intended to be used 
        directly from the 
        <c>Element.get(String pathString)</c> and
        <c>NodeSet.get(String pathString)</c> methods.
      </p>
      <code caption="Select host 'john' from the configuration tree"><![CDATA[
      NodeSet full_config = session.getConfig();
      NodeSet all_johns = full_config.get("hosts/host[name='john']");
      Element john = all_johns.first();
      ]]></code>        

      <p>
        From the full configuration received a selection is made locally
        with <c>get("hosts/host[name='john']")</c>.
        The path expression is evaluated on the context node from top to bottom.
	The context node is the node we invoke the 'get' method on, e.g the selecion
	is made from this node.
      </p>
      
      <p>
        The expression consists of a number of steps separated with '/', so
        the expression contains two steps: <c>hosts</c> and 
        <c>host[name='john']</c>.
        The last step also contains a predicate (a test which evaluates to 
        either 'true' or 'false').
        The result of evaluating each step is a <em>NodeSet</em> of elements, 
        that is given as a context to the next step. When all steps are 
        evaluated the resulting <em>NodeSet</em> is returned.
        <ol>
          <li>
            Select all <c>hosts</c> children of the context node.
          </li>
          <li>
            Select all <c>host</c> children of the nodes from the previous 
            step. Only include the nodes where the predicate expression 
            <c>name='john'</c> evaluates to 'true'.
          </li>
        </ol>
        So the meaning of the expression is: 
        <em>"select all host elements with a child named 'name' whose 
        value is 'john'"</em>.
      </p>
    </body>
  </section>
  
  
  <section>
    <title>Creating an element subtree</title>
    <body>        
      <p>
        To create a new element subtree there are class methods for 
        create in <c>Element.create(Prefix prefix,String pathStr)</c>.
        This is convenient for creating for example <em>subtree filters</em>.
        A prefix map needs to be given to resolve prefixes in the path. A 
        namespace can also be given if no prefixes are used in the path.
      </p>
      <code caption="Select 'hosts' from the configuration tree"><![CDATA[
      Element subtreeFilter = Element.create("http://tail-f.com/ns/simple/1.0","/hosts");
      NodeSet hosts = sess.get(subtreeFilter);
      ]]></code>        
    </body>
  </section>


  <section>
    <title>Attributes</title>
    <body>        
      <p>
        Configuration elements can have attributes.
        For each element there is a set of attributes attached to it.
        To set an attribute the <c>Element.setAttr(String name,String value)</c>
        should be used. And to get the attribute(s) <c>getAttrs()</c> and 
        <c>getAttr(String attrName)</c> can be used. <br/>
        Attributes can also be given in <em>create path expressions</em> as 
        shown in the following example.
        In the following example the attribute "myattr" 
        (attributes are prefixed with '@') is created on the host element.
      </p>
      <code caption="Create host with attribute"><![CDATA[
      Element tree = Element.create("http://tail-f.com/ns/simple/1.0",
                                      "/hosts/host[name='john', @myattr='enabled']");
      ]]></code>        
    </body>
  </section>
  
  <section>
    <title>Modifying configuration element subtrees with NETCONF</title>
    <body>        
      <p>
        To modify elements on the device the <em>editConfig</em> operation is 
        used and a configuration tree is provided as an argument.
        The configuration is sent to the device, which will be updated with 
        the new configuration. For each configuration element it is possible 
        to set an operation attribute which is used for controlling what needs 
        to be done. The value is one of: <em>create</em>, <em>delete</em>, 
        <em>replace</em> or <em>merge</em>.
        The meaning is the following:
        <dl termtype="em">
          <dt>delete</dt>
	  <dd>The element and its subtree will be deleted</dd>
          <dt>create</dt>
          <dd>A new instance will be created</dd>
          <dt>merge</dt>
          <dd>Merges this configuration with the existing one</dd>
          <dt>replace</dt>
          <dd>Replaces the configuration with this one</dd>
        </dl>
        The operation attribute can be set with the following methods:
        <c>markDelete()</c>, <c>markReplace()</c>, <c>markMerge()</c>, 
        <c>markCreate()</c>.
        For example the <c>markCreate()</c> is the equivalent of setting
        the operation attribute to 'create':
        <c>setAttr(Element.NETCONF_NAMESPACE,"operation","create")</c>
        
      </p>
      <p>
        The following is an example of how to delete a 'host' node 
        whose name (sub-element) is 'john'.
      </p>
      <code caption="Delete host 'john'"><![CDATA[
      Element hosts = Element.create("http://tail-f.com/ns/simple/1.0",
                                       "/hosts/host[name='john']");
      hosts.markDelete("host[name='john']");
      sess.editConfig(hosts);
      ]]></code>                  

      <p>
        Consider the following code which will create a subtree filter 
        that creates a <em>host</em> and deletes a <em>host</em> in a device:
      </p>          

      <code caption="Core for creating a host and deleteing another host"><![CDATA[
      Element hosts = Element.create("http://tail-f.com/ns/simple/1.0","/hosts");
      Element ola = hosts.createPath("host[name='ola', address='10.0.0.4']");
      Element john= hosts.createPath("host[name='john', address='10.0.0.5']");
      ola.markDelete();
      john.markCreate();
      System.out.println( hosts.toXMLString() );
      session.editConfig(hosts);
      ]]></code>                  
      <p>
        This will result in the following element tree:
      </p>
      <img src="../pics/hosts-tree.png"
           width="16.5cm"
           caption="A tree of Element objects"/>


      <p>
        The printed tree will look like this:
      </p>
      <code caption="The printed XML tree"><![CDATA[
<hosts xmlns="http://tail-f.com/ns/simple/1.0">
    <host xc:operation="delete">
      <name>ola</name>
      <address>10.0.0.4</address>
    </host>
      <host xc:operation="create">
      <name>john</name>
      <address>10.0.0.5</address>
    </host>
</hosts>
      ]]></code>
      <p>
        Notice that the prefix 'xc' on the operations attributes are 
        a default prefix mapping of 'xc' to the NETCONF namespace
        "urn:ietf:params:xml:ns:netconf:base:1.0" where the 
        <em>operations</em> attribute is stored.
        The default prefix mappings can be changed. 
        They are fully accessible from <c>Element.defaultPrefixes</c>.
      </p>
    </body>
  </section>

  <section>
    <title>Writing configuration</title>
    <body>        
      <p>
        Configuration element trees can be converted to an XML string
        representation with the <c>toXMLString()</c> method.
        This can be used for saving the configuration to a file for example.
      </p>
      <code caption="Save configuration to file"><![CDATA[
      // get config from device
      NodeSet config = sess.getConfig();
      // Open an output stream
      fout = new FileOutputStream ("myconfig.xml");
      // Print the config
      new PrintStream(fout).println( config.toXMLString() );
      fout.close();             
      ]]></code>                  
    </body>
  </section>
  
  <section>
    <title>Reading configuration</title>
    <body>        
      <p>
        Configuration returned from the NETCONF session is
        parsed with the <em>XMLParser</em> class.
        This will build up a configuration tree. The 
        same parser can be used for reading a configuration file.
      </p>
      <code caption="Read configuration from file"><![CDATA[
      String filename = "myconfig.xml";
      Element tree = new XMLParser().readFile(filename);
      System.out.println( tree.toXMLString() );
      ]]></code>                  
    </body>
  </section>

  <section>
    <title>Prefixes</title>
    <body>        
      <p>
        Prefixes are used in path expressions to express that elements
        belong to a certain namespace. A prefix-mapping must be given 
        in order to resolve the namespace from a prefix.
        For example:
      </p>
      <code caption="Create element tree which belongs to different namespace"><![CDATA[
      Element t = Element.create( new Prefix("aaa","http://aaa/ns"),
                                    "/aaa:hosts/aaa:host");
      ]]></code>                  
      <p> 
        The elements prefixed with 'aaa' will belong to the namespace "http://aaa/ns".
      </p>
      <p> There is also a default prefix map which is a convenient
      place to have common prefix mappings stored.
      It is a static <em>PrefixMap</em> in the <em>Element</em> class.
      For example the 'operation' attributes belong to the 
      namespace "urn:ietf:params:xml:ns:netconf:base:1.0". 
      To not have to set a prefix map on every <em>Element</em> element
      where the attribute 'operation' is used, it is simply put in a top level
      default prefix map, which is put in the RPC header of every 
      NETCONF message.
      </p>
      <code caption="Add a default prefix mapping of 'aaa' to our commonly used namespace"><![CDATA[
      Element.defaultPrefixes.set( new Prefix("aaa", "http://aaa/ns/whatever"));
      ]]></code>                
      <p>
        Note that prefixes as well as namespaces need to be unique.
        Two prefixes mapping to the same namespace are not allowed.
      </p>
    </body>
  </section>

</chapter>

