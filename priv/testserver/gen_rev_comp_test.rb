#!/usr/bin/env ruby -wKU

load "gen_util.rb"

# ====================================
# = Erlang code generation functions =
# ====================================
def erl_testcase(name, key, got, doc = "")
<<-eos
#{name}(doc) -> [{userdata,[{"#{doc}"}]}];
#{name}(Config) -> 
  {value,{_,Pid}}=lists:keysearch(?MODULE,1,Config),
  io:format("in test case Pid is ~p MODULE is ~p~n Key is ~p",[Pid,?MODULE,#{key}]),
  Pid ! {msg,self(),?MODULE,#{key}},
  receive
    Msg -> 
      io:format("Expected is :~p~nGot is      :~p~n",[Msg,#{got}]),
      test_util:expected2(Msg, #{got})
  after
    500 -> io:format("timed out in test case!~n"),
            exit("die in flames!")
  end.
  
eos
end

def module_header(source_file, timestamp, modname)
<<-eos
% This module has been generated by gen_rev_comp_test.rb
% DO NOT EDIT MANUALLY.
%
% Source file: #{source_file}
% Generated on: #{timestamp}

-module(#{modname}).
-compile(export_all).
-include("ct.hrl").


eos
end

def init_per_suite(xlsfile)
<<-eos
init_per_suite(Config) ->
    code:add_patha("../../../../../ebin"),
    production_boot:setup_paths(),
    Data = test_util:read_excel_file("../../../../excel_files/Win_Excel07_As_97/#{xlsfile}"),
    %% io:format("in init_per_suite Data is ~p~n",[Data]),
    Pid=spawn(test_util,test_state,[Data]),
    io:format("in init_per_suite Pid is ~p~n",[Pid]),
    [{?MODULE,Pid}|Config].
  
eos
end

def end_per_suite
<<-eos
end_per_suite(_Config) ->
    ok.
  
eos
end

def init_per_testcase
<<-eos
init_per_testcase(_TestCase, Config) -> Config.

eos
end

def end_per_testcase
<<-eos
end_per_testcase(_TestCase, _Config) -> ok.

eos
end

def read_from_excel_data(mod_name)
<<-eos
read_from_excel_data(Config,{Sheet,Row,Col}) ->
  test_util:read_from_excel_data(Config,#{mod_name},{Sheet,Row,Col}).

eos
end

def all(test_cases)
<<-eos
all() -> 
    [#{test_cases}
    ].
  
eos
end

# ==============================================================
# = Main part: read YAML file, and generate test case from it. =
# ==============================================================

datafile = ARGV[0]
ranges = ARGV.slice(1..-1)

data = eval(IO.readlines(datafile).join)

basename = File.basename(ARGV[0], ".dat").downcase
modname = "#{basename}_SUITE"

File.open("#{modname}.erl", "w") do |suite|
  suite << (module_header("#{basename}.xls", Time.now.to_s, modname) +
            init_per_suite("#{basename}.xls") +
            end_per_suite() +
            init_per_testcase() +
            end_per_testcase() + 
            read_from_excel_data(modname))
  
  # Keep a list of names of generated test cases for all().
  test_names = []

  data.each_with_index { |sheetdata, sheetidx|
    currange = ranges[sheetidx] == nil ? [] : expand_range(ranges[sheetidx])
    sheetdata.slice(1..-1).map { |rowdata|
      if rowdata.length > 1
        rowdata.map { |celldata|
          if celldata.kind_of?(Array)
            if currange == [] || currange.include?([celldata[0], rowdata[0]])
              cellname = itob26(celldata[0]) + rowdata[0].to_s # make A1-style name
              casename = "sheet#{sheetidx + 1}_#{cellname}"
              test_names << casename

              value = celldata[1][:value]
              formula = celldata[1][:formula]
              
              type = (if formula.length > 1 && formula[0].chr == "="
                        :formula
                      elsif value.kind_of?(Numeric)
                        :number
                      elsif value.kind_of?(String)
                        :string
                      elsif value.kind_of?(TrueClass)
                        :boolean
                      elsif value.kind_of?(FalseClass)
                        :boolean
                      end)
              
              got = (if type == :formula
                       formula.inspect # gsub("\\", "\\\\\\").gsub("\"", "\\\"") +
                     elsif type == :string
                       value.inspect
                     elsif type == :number
                       value
                     else # boolean
                       value.to_s
                     end)
              got2 = "{#{type.to_s},#{got}}"
              key="{\"#{sheetdata[0]}\",#{rowdata[0]-1},#{celldata[0]-1}}"
              suite << erl_testcase(casename, key, got2)
            end
          end
        }
      end
    }
  }

  suite << all(test_names.join(",\n   ")) 
end
