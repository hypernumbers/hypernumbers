#!/usr/bin/env ruby -wKU

require "yaml"

# ====================================
# = Erlang code generation functions =
# ====================================
def erl_testcase(name, expected, got, output, doc = "")
<<-eos
#{name}(doc) -> [{userdata,[{"#{doc}"}]}];
#{name}(_Config) -> 
  Got=#{got},
  Expected=#{expected},
  #{output}
  test_util:expected(Expected,Got).
  
eos
end

def module_header(source_file, timestamp, modname)
<<-eos
% This module has been generated by gen_full_test.rb
% DO NOT EDIT MANUALLY.
%
% Source file: #{source_file}
% Generated on: #{timestamp}

-module(#{modname}).
-compile(export_all).
-include("ct.hrl").

eos
end

def init_per_suite(full_test_file,mod_name)
<<-eos
init_per_suite(Config) ->
    code:add_patha("../../../../../ebin"),
    production_boot:start(),
    test_util:wait(),
    io:format("dumping current path next: "),
    c:pwd(),
    Data = test_util:read_excel_file("../../excel_files/Win Excel 2007 (as 97)/#{full_test_file}"),
    Fun =fun({{{sheet,Sheet},{row_index,RowIdx},{col_index,ColIdx}},Input}) ->
      io:format("Sheet is ~p RowIdx is ~p and ColIdx is ~p~n",[Sheet,RowIdx,ColIdx]),
      Data1 = case Input of
        {_,Data2}                                -> Data2;
        {_,number,Data2} when is_float(Data2)   -> float_to_list(Data2);
        {_,number,Data2} when is_integer(Data2) -> integer_to_list(Data2);
        {_,error,Error}                          -> Error;
        {_,boolean,true}                         -> "true";
        {_,boolean,false}                        -> "false"
      end,
      Path="/"++Sheet++"/",
      Cell=util2:make_b26(ColIdx+1)++integer_to_list(RowIdx+1),
      io:format("Cell is ~p~n",[Cell]),
      hn_post("http://127.0.0.1:9000",Path,Cell,Data1) end,
    lists:map(Fun,Data),
    io:format("in init_per_suite Data is ~p~n",[Data]),
    Config.
  
eos
end

def end_per_suite
<<-eos
end_per_suite(_Config) ->
    production_boot:stop(),
    ok.
  
eos
end

def init_per_testcase
<<-eos
init_per_testcase(_TestCase, Config) -> Config.

eos
end

def end_per_testcase
<<-eos
end_per_testcase(_TestCase, _Config) -> ok.

eos
end

def read_from_excel_data(mod_name)
<<-eos
read_from_excel_data(Config,{Sheet,Row,Col}) ->
  test_util:read_from_excel_data(Config,#{mod_name},{Sheet,Row,Col}).

eos
end

def all(test_cases)
<<-eos
all() -> 
    [#{test_cases}
    ].
  
eos
end

def helper()
<<-eos
%%% Helper functions.

hn_post(Site, Path, Cell, Data) ->
    Url=Site++Path++Cell,
    PostData = "<create><value>" ++Data++"</value></create>",
    Data2 = {Url, [], "text/plain", PostData},
    io:format("in hn_post Data is ~p~n",[Data2]),
    Return = http:request(post, Data2, [], []),
    io:format("in hn_post return from POST is ~p~n",[Return]),
    {ok, {{V, 200, R}, H, Body}} = Return.


hn_get(Site,Path,Cell) ->
    io:format("in hn_get Site is ~p Path is ~p and Cell is ~p~n",[Site,Path,Cell]),
    Url=Site++Path++Cell,
    io:format("in hn_get Url is ~p~n",[Url]),
    {ok, {{V, 200, R}, H, Body}} = http:request(get, {Url, []}, [], []),
    io:format("in hn_get body is ~p~n",[Body]),
    %%stdext:text2num(Body). %% Assume it's all numbers for now.
    Body.

assert_eql(X, Y) when is_integer(X) andalso is_float(Y) ->
    X * 1.0 == Y;
assert_eql(X, Y) when is_float(X) andalso is_integer(Y) ->
    X == Y * 1.0;
assert_eql(X, Y) ->
    X == Y.
    
eos
end
# ==============================================================
# = Main part: read YAML file, and generate test case from it. =
# ==============================================================

test_file=ARGV[0]
load_file=ARGV[1]
#puts "the test Yaml is #{test_file} and the load Yaml is #{load_file}"

test_hash = File.open(test_file) { |f| YAML::load(f) }
load_hash = File.open(load_file) { |f| YAML::load(f) }

modname = "#{File.basename(ARGV[0], "_test.yaml").downcase}_SUITE"
#puts "modname is #{modname}"

#puts "test_hash is #{test_hash}"
#puts "load_hash is #{load_hash}"

File.open("#{modname}.erl", "w") do |suite|
  suite << module_header(test_hash["source-file"], Time.now.to_s, modname) +
           init_per_suite(load_hash["source-file"], modname) +
           end_per_suite() +
           init_per_testcase() +
           end_per_testcase() + 
           read_from_excel_data(modname) +
           helper()
  
  # Keep a list of names of generated test cases for all().
  test_names = []
  
  # Write test cases.
  test_hash.each do |sheet|
    #puts "sheet is #{sheet}"
     if sheet[0] != "source-file" && sheet[0] != "generated-on"
      sheet[1].each do |col_cells|
      #puts "col_cells are #{col_cells}"
      # col_cells will contain something like:
      # ["B", 
      #   { 5 => {"formula"=>"=UPPER(\"hello\")", "value"=>"HELLO"}, 
      #     3 => {"formula"=>"=1>0", "value"=>true},
      #     4 => {"formula"=>"zhopa", "value"=>"zhopa"}}]
      # Where "B" is, of course, the name of the column, and the elements in the
      # hash are { row_number => value } pairs.
    
        col_cells[1].each do |row_data|
          #puts "row data is #{row_data}"
          # row_data data will contain something like:
          # [1, {"formula" => "=2 * 2.5", "value" => 5}]
        
          # This will give us a name like sheet1_c15_test
          name = "#{sheet[0].downcase}_#{col_cells[0].downcase}#{row_data[0]}_test"
          test_names << name
          #puts "row_data[\"value\"] is #{row_data[\"value\"]}"
          expected="\"#{row_data[1]["value"].to_s}\""
          #puts "expected is #{expected}"
        got="hn_get(\"http://127.0.0.1:9000\",\"/#{sheet[0]}/\",\"#{col_cells[0].downcase}#{row_data[0]}\")"
          output = "io:format(\"Expected : ~p~nGot      : ~p~n\",[Expected,Got]),"
        #puts "expected is #{expected} and got is #{got}"
        suite << erl_testcase(name, expected, got, output)
        end
      end
    end
  end
  
  # Three spaces after the line break, so that the output is formatted nicely.
  suite << all(test_names.join(",\n   ")) 
end