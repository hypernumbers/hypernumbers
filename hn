#!/usr/bin/env escript
%% -*- erlang -*-
%%! -boot ebin/start_ssl -proto_dist inet_ssl -ssl_dist_opt server_certfile "priv/keys/servercert.pem" -ssl_dist_opt client_certfile "priv/keys/clientcert.pem" -ssl_dist_opt keyfile "priv/keys/key.pem"

cookie() ->
    completelysecure.

main([]) ->
    usage();

main(Args) ->
    %% Prevent starting as root.
    case os:getenv("USER") of
        "root" -> exit("Don't run me as root!");
        _      -> ok end,

    os:cmd("/usr/local/bin/epmd -daemon"),
    %% Because ssl sucks(I cant set -name on the escript args)

    {ok, _} = net_kernel:start([ctrl_node(), longnames]),
    auth:set_cookie(cookie()),

    %% cd into own directory
    ok = file:set_cwd(filename:dirname(escript:script_name())),
    try dispatch(Args)
    catch throw:Error ->
            io:format("Error running script:~n  ~p",[Error])
    end,
    net_kernel:stop().

dispatch(["build"]) -> 
    build(), 
    remote_do(hotswap);

dispatch(["lexer-parser"]) -> 
    build_lexer_parser(),
    build_quick(),
    remote_do(hotswap);

dispatch(["quick"]) -> 
    build_quick(),
    remote_do(hotswap);

dispatch(["migrate"]) -> 
    %% Force any unloaded modules to be loaded, BEFORE any compilation.
    remote_do(hotswap),
    clean(),
    build(),
    remote_do(migrate);

dispatch(["plainbuild"]) -> build();
dispatch(["clean"]) -> clean();
dispatch(["start" | Args]) -> start(Args);
dispatch(["stop" | Node]) -> stop(Node);
dispatch(["call" | Args]) -> call(Args);
dispatch(["do", Cmd | Node]) -> remote_do(Cmd, Node);
dispatch(_BadCommand) -> usage().
    
build() ->

    io:format("This should be done in compile_code so it can be run from load_cluster~n~n"),
    ensure_config(),

    {ok, Root} = file:get_cwd(),

    io:format("Compiling Dependencies ...~n"),

    filelib:ensure_dir("lib/mochiweb/ebin/"),
    filelib:ensure_dir("lib/hypernumbers-1.0/ebin/"),
    filelib:ensure_dir("ebin/"),

    file:set_cwd("lib/mochiweb"), 
    os:cmd("make"),
    file:set_cwd(Root),
    file:set_cwd("lib/gettext"),
    os:cmd("make"),
    file:set_cwd(Root),
    file:set_cwd("lib/starling"),
    io:format(os:cmd("rake")),
    file:set_cwd(Root),
    build_lexer_parser(),
    compile:file("src/compile_code.erl", [{outdir, "ebin"}]),
    
    compile:file("priv/ms_util/make_ms_util.erl",
                 [{outdir, "lib/hypernumbers-1.0/ebin"}, debug_info,
                  {i, "lib/hypernumbers-1.0/include"}]),
    code:add_path("lib/hypernumbers-1.0/ebin"),
    make_ms_util:make(),
    {ok, _Bytes} =
        file:copy("ms_util2.erl", "lib/hypernumbers-1.0/src/ms_util2.erl"),
    ok = file:delete("ms_util2.erl"),

    file:set_cwd(Root++"/ebin"),
    compile_code:start(),
    file:set_cwd(Root).

build_lexer_parser() ->
    {ok, Root} = file:get_cwd(),
    file:set_cwd("lib/formula_engine-1.0/priv/"),
    Ret = os:cmd("./generate.escript"),
    io:format("~p~n", [Ret]),
    file:set_cwd(Root).
    
build_quick() ->
    {ok, Root} = file:get_cwd(),
    ensure_config(),
    file:set_cwd(Root++"/ebin"),
    compile_code:quick(),
    file:set_cwd(Root++"/lib/hypernumbers-1.0/priv/core_install/docroot/"),
    print_msgs(string:tokens(os:cmd("grep -R -l console.log *"), "\n")),
    file:set_cwd(Root).

clean() ->
    Files = filelib:wildcard("lib/*/ebin/*.beam") ++ 
        filelib:wildcard("ebin/*.beam"),
    [file:delete(F) || F <- Files],
    ok.

start(Extra) ->
    
    ensure_config(),
    Node = atol(conf_lname()),
    PipeDir = "/tmp/" ++ Node ++ "/",
    
    filelib:ensure_dir("var/runerl_log/"),
    filelib:ensure_dir(PipeDir),
    
    Cmd = "run_erl -daemon "++PipeDir ++ " var/runerl_log "
        "\"erl -name "++Node++" -setcookie "++atol(cookie())++" "
        "-config var/sys.config -boot ebin/hypernumbers "
        "-env ERL_MAX_ETS_TABLES 18000 "
        "+K true +A8 "
        ++ ssl() ++ parse_extra_args(Extra)++"\"",

    case os:cmd(Cmd) of
        []   -> 
            ok,
            make_shell(Node);
        Else ->
            io:format("Hypernumbers failed to boot:~n~s~n",[Else]),
            ok
    end.

stop(Node) ->
    ok = rpc:call(lname(Node), init, stop, []).

make_shell(NodeName) ->
    Shell = io_lib:format("#!/bin/bash~nto_erl /tmp/~s/~n", [NodeName]),
    file:write_file("shell", Shell),
    os:cmd("chmod +x shell").

call([Fun]) ->
    call([lname([]), Fun]);
call([Node, Fun]) ->
    {ok, Tokens, _End} = erl_scan:string(Fun),
    {ok, Expr}         = erl_parse:parse_exprs(Tokens),
    %% Bit ugly
    [{call, 1, {remote, 1, {atom, 1, M}, {atom, 1, F}}, Args}] = Expr,
    A = [ Val || {_Type, _I, Val} <- Args],
    
    io:format("~p~n",[rpc:call(Node, M, F, A)]).

remote_do(Cmd) when is_list(Cmd) ->
    remote_do(list_to_atom(Cmd));
remote_do(Cmd) ->
    remote_do(Cmd, conf_lname()).
remote_do(Cmd, []) ->
    remote_do(Cmd, conf_lname());
remote_do(Cmd, Node) when is_list(Cmd) ->
    remote_do(list_to_atom(Cmd), Node);
remote_do(Cmd, [Node]) when is_list(Node) ->
    remote_do(Cmd, list_to_atom(Node));
remote_do(Cmd, Node) ->
    case net_adm:ping(Node) of
        pong  -> 
             io:format("Send ~s => ~s~n", [Cmd, Node]),
             ok = rpc:call(Node, hn_updater, do, [Cmd]);
        _Else ->
            io:format("Failed to ping ~p~n", [Node]),
            ok
    end.

ensure_config() ->    
    case has_config() of
        false -> copy_default_config();
        true  -> ok
    end.    

parse_extra_args(Args) ->
    parse_extra_args(Args, []).
parse_extra_args([], Acc) ->
    lists:flatten(string:join(lists:reverse(Acc), " "));
parse_extra_args([Key, Value | Rest], Acc) ->
    Setting = ["-", Key, " ", Value],
    parse_extra_args(Rest, [Setting | Acc]);
parse_extra_args(_, Acc) ->
    %% todo, add support for 3-val env settings
    parse_extra_args([], Acc).


has_config() ->
    filelib:is_file(config_file()).

read_config(Key) ->
    {ok, [Config]}         = file:consult(config_file()),
    {hypernumbers, HNConf} = lists:keyfind(hypernumbers, 1, Config),
    {Key, Val}             = lists:keyfind(Key, 1, HNConf),
    Val.

config_file() ->
    [root(), "/var/", "sys.config"].
    %% ok.

%% If node is specified in command, pick that up, if
%% no, pick up from local.node file, if that doesnt exist
%% create a default one called arrian
copy_default_config() ->
    ok = filelib:ensure_dir([root(), "/var/"]),
    {ok, _Bytes} =
        file:copy([root(), "/priv/", "sys.config.default"], config_file()),
    ok.

lname([]) ->
    conf_lname();
lname([Name]) ->
    list_to_atom(Name).

conf_lname() ->
    nodeatom(read_config(nodename)).

nodeatom(Name) ->
    Host     = string:strip(os:cmd("hostname"), both, $\n),
    LongName = io_lib:format("~s@~s", [Name, Host]),    
    ltoa(lists:flatten(LongName)).

ltoa(L) ->
    list_to_atom(L).
atol(A) ->
    atom_to_list(A).

root() ->
    {ok, Root} = file:get_cwd(),
    Root.

ctrl_node() ->
    Fmt = "~2.10.0B-~2.10.0B-~2.10.0B",
    {_, {H,M,S}} = calendar:universal_time(),
    Date = io_lib:format(Fmt, [H,M,S]),
    list_to_atom(lists:flatten(["ctrl-", Date, "@", net_adm:localhost()])).
            
usage() ->
    Usage = "Commands to run hypernumbers are:~n"
        "  start [erl_args]~n"
        "  stop [remote@host.com]~n"
        "  do refresh|hotswap|restart|migrate [remote@host.com]~n"
        "~nCommands to build hypernumbers are:~n"
        "  build ~n"
        "  quick ~n"
        "  lexer-parser ~n"
        "  migrate ~n",
        "  clean ~n",
    io:format(Usage),
    halt(1).

ssl() ->
    "-ssl_dist_opt server_certfile \"priv/keys/servercert.pem\" "
        "-ssl_dist_opt client_certfile \"priv/keys/clientcert.pem\" "
        "-ssl_dist_opt keyfile \"priv/keys/key.pem\" " 
        "-proto_dist inet_ssl".

print_msgs(List) ->
    io:format("Console.log in:~n"),
    [io:format("~p~n", [X]) || X <- List]. 
