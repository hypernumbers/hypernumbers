#!/usr/bin/env escript
%% -*- erlang -*-
%%! -boot ebin/start_ssl -proto_dist inet_ssl -ssl_dist_opt server_certfile "priv/keys/servercert.pem" -ssl_dist_opt client_certfile "priv/keys/clientcert.pem" -ssl_dist_opt keyfile "priv/keys/key.pem"

cookie() ->
    completelysecure.

main([]) ->
    usage();

main(Args) ->
    %% Prevent starting as root.
    case os:getenv("USER") of
        "root" -> exit("Don't run me as root!");
        _      -> ok end,

    os:cmd("/usr/local/bin/epmd -daemon"),
    %% Because ssl sucks(I cant set -name on the escript args)

    {ok, _} = net_kernel:start([ctrl_node(), longnames]),
    auth:set_cookie(cookie()),

    %% cd into own directory
    ok = file:set_cwd(filename:dirname(escript:script_name())),
    try dispatch(Args)
    catch throw:Error ->
            io:format("Error running script:~n  ~p",[Error])
    end,
    net_kernel:stop().

dispatch(["build"]) ->
    {ok, Root} = file:get_cwd(),
    build(Root),
    file:set_cwd(Root),
    remote_do(hotswap);

dispatch(["lexer-parser"]) ->
    {ok, Root} = file:get_cwd(),
    build_lexer_parser(Root),
    file:set_cwd(Root),
    remote_do(hotswap);

dispatch(["quick"]) ->
    {ok, Root} = file:get_cwd(),
    build_quick(Root),
    file:set_cwd(Root),
    remote_do(hotswap);

dispatch(["migrate"]) ->
    %% Force any unloaded modules to be loaded, BEFORE any compilation.
    remote_do(hotswap),
    {ok, Root} = file:get_cwd(),
    clean(Root),
    build(Root),
    remote_do(migrate);

dispatch(["plainbuild"])       -> {ok, Root} = file:get_cwd(),
                                  build(Root);
dispatch(["clean"])            -> {ok, Root} = file:get_cwd(),
                                  clean(Root);
dispatch(["start" | Args])     -> start(Args);
dispatch(["debug" | Args])     -> debug(Args);
dispatch(["no_mnesia" | Args]) -> no_mnesia(Args);
dispatch(["stop" | Node])      -> stop(Node);
dispatch(["call" | Args])      -> call(Args);
dispatch(["do", Cmd | Node])   -> remote_do(Cmd, Node);
dispatch(_BadCommand)          -> usage().

build(Root) ->

    io:format("This should be done in compile_code so it can be run"
              ++" from load_cluster~n~n"),
    ensure_config(),
    clean(Root),
    io:format("Compiling Dependencies ...~n"),
    filelib:ensure_dir("lib/mochiweb/ebin/"),
    filelib:ensure_dir("lib/hypernumbers-1.0/ebin/"),
    filelib:ensure_dir("ebin/"),
    io:format("...building mochiweb~n"),
    file:set_cwd("lib/mochiweb"),
    os:cmd("make"),
    file:set_cwd(Root),
    file:set_cwd("lib/gettext"),
    io:format("...building gettext~n"),
    os:cmd("make"),
    file:set_cwd(Root),
    file:set_cwd("lib/starling"),
    io:format("...building starling~n"),
    io:format(os:cmd("rake")),
    file:set_cwd(Root),
    file:set_cwd("lib/twilio"),
    io:format("...building twilio~n"),
    io:format(os:cmd("./rebar compile")),
    file:set_cwd(Root),
    file:set_cwd("lib/erlsha2"),
    io:format("...building erlsha2~n"),
    io:format(os:cmd("./rebar compile")),
    file:set_cwd(Root),

    % build the lexer-parsers
    io:format("...building lexer-parser~n"),
    make_lexer_parser(Root),
    io:format("...compiling compile_code.erl~n"),
    compile:file("src/compile_code.erl", [{outdir, "ebin"}]),
    minify(Root),
    make_ms_util(Root),
    file:set_cwd(Root++"/ebin"),
    io:format("...now compile all the actual code~n"),
    compile_code:start(),
    check_console_log(Root).

build_lexer_parser(Root) ->
    make_ms_util(Root),
    make_lexer_parser(Root),
    minify(Root),
    make_quick(Root),
    check_console_log(Root).

build_quick(Root) ->
    make_ms_util(Root),
    minify(Root),
    make_quick(Root),
    check_console_log(Root).

minify(Root) ->
    Dir = Root ++ "/lib/hypernumbers-1.0/priv/core_install/minify.specs/",
    Prefix = Root ++ "/lib/hypernumbers-1.0/priv/core_install/docroot",
    Files = filelib:wildcard(Dir ++ "*.specs"),
    min2(Files, Prefix),
    ok.

min2([], _Prefix) ->
    ok;
min2([H | T], Prefix) ->
    File = filename:basename(H),
    [View, "minify", "specs"] = string:tokens(File, "."),
    {ok, [Specs]} = file:consult(H),
    min3(Specs, View, Prefix),
    min2(T, Prefix).

min3([], _View, _Prefix) ->
    ok;
min3([{Where, What} | T], View, Prefix) ->
    min4(What, View, Where, Prefix),
    min3(T, View, Prefix).

min4([], _View, _Where, _Prefix) ->
    ok;
min4([{Type, Files} | T], View, Where, Prefix) ->
    min5(Files, View, Type, Where, Prefix, []),
    min4(T, View, Where, Prefix).

% fake ending - if the Acc is [] just delete the old version of the file
% if it exists
min5([], View, Type, Where, Prefix, []) ->
    File = string:join([View, atom_to_list(Where), atom_to_list(Type)], "."),
    % we don't care if the file exists when we delete it so don't check
    % the return value
    _ = file:delete(Prefix ++ "/" ++ File);
min5([], View, Type, Where, Prefix, Acc) ->
    Contents = lists:reverse(Acc),
    File = string:join([View, atom_to_list(Where), atom_to_list(Type)], "."),
    ok = file:write_file(Prefix ++ "/" ++ File, lists:flatten(Contents));
min5([{Size, File} | T], View, Type, Where, Prefix, Acc) ->
    {ok, Contents} = file:read_file(Prefix ++ File),
    NewAcc = min6(File, Contents, Size),
    min5(T, View, Type, Where, Prefix, [NewAcc | Acc]).

min6(File, Contents, max) ->
    io_lib:format("/*~n~s~n*/~n~n~s~n", [File, Contents]);
min6(_File, _Contents, min) ->
    exit("yeah, not minifying yet...").

make_ms_util(Root) ->
    file:set_cwd(Root),
    compile:file("priv/ms_util/make_ms_util.erl",
                 [{outdir, "lib/hypernumbers-1.0/ebin"}, debug_info,
                  {i, "lib/hypernumbers-1.0/include"}]),
    code:add_path("lib/hypernumbers-1.0/ebin"),
    make_ms_util:make(),
    {ok, _Bytes} =
        file:copy("ms_util2.erl", "lib/hypernumbers-1.0/src/ms_util2.erl"),
    ok = file:delete("ms_util2.erl").

make_lexer_parser(Root) ->
    file:set_cwd("lib/formula_engine-1.0/priv/"),
    os:cmd("./generate.escript"),
    file:set_cwd(Root).

make_quick(Root) ->
    ensure_config(),
    file:set_cwd(Root++"/ebin"),
    compile_code:quick(),
    file:set_cwd(Root).

check_console_log(Root) ->
    file:set_cwd(Root++"/lib/hypernumbers-1.0/priv/core_install/docroot/"),
    print_msgs(string:tokens(os:cmd("grep -R -l console.log *"), "\n")).

clean(Root) ->
    Files = filelib:wildcard(Root ++ "lib/*/ebin/*.beam") ++
        filelib:wildcard("ebin/*.beam"),
    [file:delete(F) || F <- Files],
    ok.

start(Extra) ->

    ensure_config(),
    Node = atol(conf_lname()),
    PipeDir = "/tmp/" ++ Node ++ "/",

    filelib:ensure_dir("var/runerl_log/"),
    filelib:ensure_dir(PipeDir),

    Cmd = "run_erl -daemon "++PipeDir ++ " var/runerl_log "
        "\"erl -name "++Node++" -setcookie "++atol(cookie())++" "
        "-config var/sys.config -boot ebin/hypernumbers "
        "-env ERL_MAX_ETS_TABLES 18000 -kernel net_setuptime 120 "
        "+K true +A8 "
        ++ ssl() ++ parse_extra_args(Extra)++"\"",

    case os:cmd(Cmd) of
        []   ->
            ok,
            make_shell(Node);
        Else ->
            io:format("Hypernumbers failed to boot:~n~s~n",[Else]),
            ok
    end.

debug(Extra) ->

    ensure_config(),
    Node = atol(conf_lname()),
    PipeDir = "/tmp/" ++ Node ++ "/",

    filelib:ensure_dir("var/runerl_log/"),
    filelib:ensure_dir(PipeDir),

    Cmd = "run_erl -daemon "++PipeDir ++ " var/runerl_log "
        "\"erl -name "++Node++" -setcookie "++atol(cookie())++" "
        "-config var/sys.config -boot ebin/debug "
        "-env ERL_MAX_ETS_TABLES 18000 -kernel net_setuptime 120 "
        "+K true +A8 "
        ++ ssl() ++ parse_extra_args(Extra)++"\"",

    case os:cmd(Cmd) of
        []   ->
            ok,
            make_shell(Node);
        Else ->
            io:format("Hypernumbers failed to boot:~n~s~n",[Else]),
            ok
    end.

no_mnesia(Extra) ->

    ensure_config(),
    Node = atol(conf_lname()),
    PipeDir = "/tmp/" ++ Node ++ "/",

    filelib:ensure_dir("var/runerl_log/"),
    filelib:ensure_dir(PipeDir),

    Cmd = "run_erl -daemon "++PipeDir ++ " var/runerl_log "
        "\"erl -name "++Node++" -setcookie "++atol(cookie())++" "
        "-config var/sys.config -boot ebin/no_mnesia "
        "-env ERL_MAX_ETS_TABLES 18000 -kernel net_setuptime 120 "
        "+K true +A8 "
        ++ ssl() ++ parse_extra_args(Extra)++"\"",

    case os:cmd(Cmd) of
        []   ->
            ok,
            make_shell(Node);
        Else ->
            io:format("Hypernumbers failed to boot:~n~s~n",[Else]),
            ok
    end.

stop(Node) ->
    ok = rpc:call(lname(Node), init, stop, []).

make_shell(NodeName) ->
    Shell = io_lib:format("#!/bin/bash~nto_erl /tmp/~s/~n", [NodeName]),
    file:write_file("shell", Shell),
    os:cmd("chmod +x shell").

call([Fun]) ->
    call([lname([]), Fun]);
call([Node, Fun]) ->
    {ok, Tokens, _End} = erl_scan:string(Fun),
    {ok, Expr}         = erl_parse:parse_exprs(Tokens),
    %% Bit ugly
    [{call, 1, {remote, 1, {atom, 1, M}, {atom, 1, F}}, Args}] = Expr,
    A = [ Val || {_Type, _I, Val} <- Args],

    io:format("~p~n",[rpc:call(Node, M, F, A)]).

remote_do(Cmd) when is_list(Cmd) ->
    remote_do(list_to_atom(Cmd));
remote_do(Cmd) ->
    remote_do(Cmd, conf_lname()).
remote_do(Cmd, []) ->
    remote_do(Cmd, conf_lname());
remote_do(Cmd, Node) when is_list(Cmd) ->
    remote_do(list_to_atom(Cmd), Node);
remote_do(Cmd, [Node]) when is_list(Node) ->
    remote_do(Cmd, list_to_atom(Node));
remote_do(Cmd, Node) ->
    case net_adm:ping(Node) of
        pong  ->
             io:format("Send ~s => ~s~n", [Cmd, Node]),
             ok = rpc:call(Node, hn_updater, do, [Cmd]);
        _Else ->
            io:format("Failed to ping ~p~n", [Node]),
            ok
    end.

ensure_config() ->
    case has_config() of
        false -> copy_default_config();
        true  -> ok
    end.

parse_extra_args(Args) ->
    parse_extra_args(Args, []).
parse_extra_args([], Acc) ->
    lists:flatten(string:join(lists:reverse(Acc), " "));
parse_extra_args([Key, Value | Rest], Acc) ->
    Setting = ["-", Key, " ", Value],
    parse_extra_args(Rest, [Setting | Acc]);
parse_extra_args(_, Acc) ->
    %% todo, add support for 3-val env settings
    parse_extra_args([], Acc).

has_config() ->
    filelib:is_file(config_file()).

read_config(Key) ->
    {ok, [Config]}         = file:consult(config_file()),
    {hypernumbers, HNConf} = lists:keyfind(hypernumbers, 1, Config),
    {Key, Val}             = lists:keyfind(Key, 1, HNConf),
    Val.

config_file() ->
    [root(), "/var/", "sys.config"].
    %% ok.

%% If node is specified in command, pick that up, if
%% no, pick up from local.node file, if that doesnt exist
%% create a default one called arrian
copy_default_config() ->
    ok = filelib:ensure_dir([root(), "/var/"]),
    {ok, _Bytes} =
        file:copy([root(), "/priv/", "sys.config.default"], config_file()),
    ok.

lname([]) ->
    conf_lname();
lname([Name]) ->
    list_to_atom(Name).

conf_lname() ->
    nodeatom(read_config(nodename)).

nodeatom(Name) ->
    Host     = string:strip(os:cmd("hostname -f"), both, $\n),
    LongName = io_lib:format("~s@~s", [Name, Host]),
    ltoa(lists:flatten(LongName)).

ltoa(L) ->
    list_to_atom(L).
atol(A) ->
    atom_to_list(A).

root() ->
    {ok, Root} = file:get_cwd(),
    Root.

ctrl_node() ->
    Fmt = "~2.10.0B-~2.10.0B-~2.10.0B",
    {_, {H,M,S}} = calendar:universal_time(),
    Date = io_lib:format(Fmt, [H,M,S]),
    list_to_atom(lists:flatten(["ctrl-", Date, "@", net_adm:localhost()])).

usage() ->
    Usage = "Commands to run hypernumbers are:~n"
        "  start [erl_args]~n"
        "  stop [remote@host.com]~n"
        "  do refresh|hotswap|restart|migrate [remote@host.com]~n"
        "~nCommands to build hypernumbers are:~n"
        "  build ~n"
        "  quick ~n"
        "  lexer-parser ~n"
        "  migrate ~n",
        "  clean ~n",
    io:format(Usage),
    halt(1).

ssl() ->
    "-ssl_dist_opt server_certfile \"priv/keys/servercert.pem\" "
        "-ssl_dist_opt client_certfile \"priv/keys/clientcert.pem\" "
        "-ssl_dist_opt keyfile \"priv/keys/key.pem\" "
        "-proto_dist inet_ssl".

print_msgs(List) ->
    io:format("Console.log in:~n"),
    [io:format("~p~n", [X]) || X <- List].
