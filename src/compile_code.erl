-module(compile_code).

-export([start/0]).

-define(init(L),
        lists:reverse(tl(lists:reverse(L)))).
%% Disable warnings for these files (generated by Leex).
-define(NO_WARNINGS,
        ["russian_lexer.erl","muin_supd_lexer.erl","muin_lexer.erl",
         "french_lexer.erl", "german_lexer.erl", "italian_lexer.erl",
         "spanish_lexer.erl", "portuguese_lexer.erl",
         "superlex.erl", "num_format_lexer.erl"]).

start() ->
    compile().

compile() ->
    [_File, _Ebin | Rest] =
        lists:reverse(string:tokens(code:which(compile_code), "/")),

	Pre = case os:type() of
              {win32,_} -> ""; 
              _ ->         "/" 
          end,

    App_rt_dir = Pre++string:join(lists:reverse(Rest),"/")++"/",

    io:fwrite("~nStarting the compilation~n~n", []),

    code:add_pathz(App_rt_dir ++ "/lib/eunit/ebin"),
    %% First set up the include file
    Inc_list = [{i, App_rt_dir ++ "/include"},
                {i, App_rt_dir ++ "/lib/read_excel-1.0/include"},
                {i, code:lib_dir(xmerl)++"/include"}],

    Dirs = lists:flatten(lists:map(
        fun(X) ->
                lists:map(fun(Y) -> {Y,X++"ebin"} end,
                          filelib:wildcard(X++"src/*.erl"))
        end,
        [App_rt_dir++"/lib/db_access-1.0/",
         App_rt_dir++"/lib/engine-1.0/",
         App_rt_dir++"/lib/hypernumbers.com-1.0/",
         App_rt_dir++"/lib/formula_engine-1.0/",
         App_rt_dir++"/lib/read_excel-1.0/",
         App_rt_dir++"/lib/remoting-1.0/",
         App_rt_dir++"/lib/utilities-1.0/",
         App_rt_dir++"/lib/mochi-1.0/"])),
    
    Extra = [
             {App_rt_dir++"priv/muin/leex.erl",App_rt_dir++"ebin"},
             {App_rt_dir++"src/bits.erl",App_rt_dir++"ebin"},
             {App_rt_dir++"src/production_boot.erl",App_rt_dir++"ebin"},
             {App_rt_dir++"src/test_util.erl",App_rt_dir++"ebin"}],
    
    compile_funcs(Dirs++Extra, Inc_list).

compile_funcs(List, Inc_list) ->
    New_list = [{X, [debug_info, {outdir, Y} | Inc_list]} || {X, Y} <- List],
    comp_lists(New_list).

comp_lists(List) ->
    comp_lists(List, ok).

comp_lists([{File, Opt}|T], OldStatus) ->
    Append = case lists:member(filename:basename(File), ?NO_WARNINGS) of
                 true ->  [return_errors];
                 false -> [return_errors,report_warnings]
             end,
    Options = lists:append(Opt,Append),

    %% Ensure output directory exists.
    [debug_info, {outdir, Dir} | _] = Options,
    filelib:ensure_dir(Dir ++ "/"),
    
    case uptodate(File) of
        false ->
            NewStatus = compile:file(File, Options),
            case NewStatus of
                {ok, FileName} ->
                    io:fwrite("OK: ~s~n", [File]),
                    code:delete(FileName),
                    code:purge(FileName),
                    code:load_file(FileName),
                    comp_lists(T, OldStatus);
                Error ->
                    io:fwrite("   Compile failure:    ~p~n", [File]),
                    io:fwrite("   Error is       :    ~p~n~n", [Error]),
                    comp_lists(T, error)
            end;
        true ->
            comp_lists(T, OldStatus)
    end;
comp_lists([], Status) ->
    io:fwrite("   Termination Status: ~p~n", [Status]),
	Status.

%% Is the beam older than the erl file?
uptodate(File) ->
    %% Find the beam corresponding to this erl file.
    Comps = string:tokens(File, "/"), % Path components
    Erlfile = lists:last(Comps),
    Modname = lists:sublist(Erlfile, length(Erlfile) - 4), % 4 <-> ".erl"
    Beam = "/" ++ string:join(?init(?init(Comps)), "/") ++ "/ebin/" ++ Modname ++ ".beam",
    %% Get last modified times for beam and erl and compare them.
    Filelastmod = filelib:last_modified(File),
    Beamlastmod = filelib:last_modified(Beam),
    Beamlastmod > Filelastmod.
