-module(compile_code).

-export([start/0]).
-include("../include/handy_macros.hrl").

-define(init(L),
        reverse(tl(reverse(L)))).
        
%% Disable warnings for these files (generated by Leex).
-define(NO_WARNINGS,
        ["russian_lexer.erl","muin_supd_lexer.erl","muin_lexer.erl",
         "french_lexer.erl", "german_lexer.erl", "italian_lexer.erl",
         "spanish_lexer.erl", "portuguese_lexer.erl",
         "superlex.erl", "num_format_lexer.erl"]).

-define(DIRS,
        ["/lib/db_access-1.0/",
         "/lib/engine-1.0/",
         "/lib/hypernumbers.com-1.0/",
         "/lib/formula_engine-1.0/",
         "/lib/read_excel-1.0/",
         "/lib/remoting-1.0/",
         "/lib/utilities-1.0/",
         "/lib/mochi-1.0/"]).

-define(EXTRA_ERL_FILES,
        ["src/misc_util.erl",   
         "priv/muin/leex.erl",
         "src/bits.erl",
         "src/production_boot.erl",
         "src/test_util.erl",
	 "src/timeout_test.erl"]).

start() ->
    compile().

compile() ->
    [_File, _Ebin | Rest] =
        reverse(string:tokens(code:which(compile_code), "/")),

	Pre = case os:type() of 
	    {win32,_} -> "";
	    _ ->         "/"
	end,
    App_rt_dir = Pre++string:join(reverse(Rest),"/")++"/",

    io:fwrite("~nStarting the compilation~n~n", []),

    code:add_pathz(App_rt_dir ++ "/lib/eunit/ebin"),
    
    %% First set up the include file
    Inc_list = [{i, App_rt_dir ++ "/include"},
                {i, App_rt_dir ++ "/lib/read_excel-1.0/include"},
                {i, App_rt_dir ++ "/lib/yaws-1.76/include"},
                {i, code:lib_dir(xmerl)++"/include"}],

    %% List of {ErlangFile, OutputDirectory} tuples.
    Dirs = flatten(map(fun(X) ->
        map(fun(Y) -> {Y, App_rt_dir ++ X ++ "ebin"} end,
        filelib:wildcard(App_rt_dir ++ X ++ "src/*.erl"))
        end,
        ?DIRS)),

    Extra = lists:map(
        fun(X) ->
            {App_rt_dir++X,App_rt_dir++"ebin"}
        end,
        ?EXTRA_ERL_FILES),
    
    compile_funcs(Dirs++Extra, Inc_list).

compile_funcs(List, Inc_list) ->
    New_list = [{X, [debug_info, {outdir, Y} | Inc_list]} || {X, Y} <- List],
    comp_lists(New_list).

comp_lists(List) ->
    comp_lists(List, ok).

comp_lists([{File, Opt}|T], OldStatus) ->
    Append = case member(filename:basename(File), ?NO_WARNINGS) of
                 true ->  [return_errors];
                 false -> [return_errors,report_warnings]
             end,
    Options = append(Opt,Append),

    %% Ensure output directory exists.
    [debug_info, {outdir, Dir} | _] = Options,
    filelib:ensure_dir(Dir ++ "/"),
    
    case uptodate(File, Dir) of
        false ->
            NewStatus = compile:file(File, Options),
            case NewStatus of
                {ok, FileName} ->
                    io:fwrite("OK: ~s~n", [File]),
                    code:delete(FileName),
                    code:purge(FileName),
                    code:load_file(FileName),
                    comp_lists(T, OldStatus);
                Error ->
                    io:fwrite("   Compile failure:    ~p~n", [File]),
                    io:fwrite("   Error is       :    ~p~n~n", [Error]),
                    comp_lists(T, error)
            end;
        true ->
            comp_lists(T, OldStatus)
    end;
comp_lists([], Status) ->
    io:fwrite("   Termination Status: ~p~n", [Status]),
	Status.

%% Is the beam older than the erl file?
uptodate(File, Dir) ->
    %% Find the beam corresponding to this erl file.
    Comps = string:tokens(File, "/"), % Path components
    Erlfile = last(Comps),
    Modname = sublist(Erlfile, length(Erlfile) - 4), % 4 <-> ".erl"
    Beam = Dir ++ "/" ++ Modname ++ ".beam",
    %% Get last modified times for beam and erl and compare them.
    Filelastmod = filelib:last_modified(File),
    Beamlastmod = filelib:last_modified(Beam),
    Beamlastmod > Filelastmod.
